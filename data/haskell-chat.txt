Hello, is there any type-level equality that works in (>= ghc 7.6.1)?
I see several libraries as candidates...
TypeNats : math operations still not possible in ghc7.6.1 main branch.
GHC.TypeLits.Symbols : no string operations supported.
HList.Label* : manually need to assign integers.
drbean pasted â€œcabal error: Distribution.PackageDescription does not export condBenchmarks.â€ at http://hpaste.org/80489
I'd like something like TypeEq x y b in Data.HList.FakePrelude, for more wider use.
HList first seemed to be promising, but it operates on very limited set of types right now...
Is the cabal not exporting of condBenchmarks the reason ghc-mod fails to build?
nushio3: you can write TypeEq as a type family in ghc HEAD
Saisan: Thank you, that's interesting!
Saizan: Thank you, that's interesting!
is there a sample for that?
then, maybe i'll prepare some mock-up for the moment, and I'll wait for ghc7.8 release.
Looks like ghc-mod needs to update its cabal requirement.
nushio3: http://typesandkinds.wordpress.com/2012/12/22/ordered-overlapping-type-family-instances/
Saizan: Thank you! I'll read.
ah, "else"for overlapping instances. This will be very useful.
nushio3: Equals a b ~ True doesn't give you a ~ b by itself though, i think
Saizan: Well, what I needed, is to put several types into Data.HList.Record and look them up.
now i'm quite sure that'll be made easy with 7.8.1
so for now, I'll defne TypeEq instances manually and pairwise, and wait 7.8.1 for future extension
also Oleg and folks are working to improve HList
Thanks again!
I have to put ~/.cabal/bin in my PATH myself?
drbean: yes
export PATH=$PATH:/home/foo/.cabal/bin
you don't need "export"
yes you do
no
PATH is already exported, you don't need to export exported variables
also: what if it wasn't already exported?
fair enough
mauke: then you would need it
pnielsen: no
mauke: Depends on how you start your shell
yes you would
if it's bash, anyway
pnielsen: no
*sigh*
I literally have 10 vars, 5 of them without export, and 5 with. echo is blank for the 5 former and complete for the remainder
mauke: my .profile starts tmux, which in turn starts bash. unexported variables don't inherit to children, so tmux and bash wouldn't see the non-exported variables
there is no reason for you to change the 'exported' status of a variable if you just want to set it
mauke: if it WASN'T exported
merijn: I consider that setup to be The Real WTF(tm)
mauke: Why?
because .profile is supposed to be read by all shells, including non-interactive ones
No it's not
you're right.
I am completely wrong, dammit
yes you are
no cookie because you were so cocksure
.bashrc and friends will also be read by non-interactive shells, and some perverse individuals symlink the two to eachother, but that's their problem
pnielsen: my retraction only applies to .profile and login shells
http://en.wikibooks.org/wiki/Haskell/Understanding_monads/IO
"The Haskell compiler needs to apply the function only four times"
can anyone please clarify this for me? how is it that it knows it only has to do it four times?
mauke: no it doesn't. You need export in .profile with bash, at least under Ubuntu
blaenk: I think that's just a blatant lie
pnielsen: for doing what?
merijn: haha, really? oh ok
blaenk: In theory, GHC could do that. In practice I don't think it usually does
mauke: for exporting the variable. I have foo="foo" and export bar="bar". Only bar is not blank. Can't explain that.
I do source .profile, and foo is foo
merijn: ah okay, thanks
pnielsen: ... yes, you need export for exporting
mauke: you were refuting this before
no, I wasn't
also: what if it wasn't already exported?
mauke: then you would need it
pnielsen: no
exactly
are you trolling?
no
whatever, don't have time for this
you're making weird assumptions
blaenk: i.e. the reasoning why GHC can do that and (for example) gcc can't is correct (GHC knows the function is pure and all that), but I don't think  GHC analyses how many duplicate elements a list has and then optimises based on that. That's not even possible for lists read/constructed at runtime
you said if it wasn't exported, do you need export in .profile
I said you do, you said no
I didn't say "... for exporintg"
*exporting
blaenk: If that's the wiki page I think it is please don't read it.
merijn: yeah that was mainly my question, how it can know or whether it checks if there's duplicates etc
elliott: oh ok, so the wikibooks book isn't a good source?
Oh, it's not the one I was thinking of. This one looks only slightly wrong.
Also, so far I don't like that wikipage
blaenk: Some parts of the wikibook are better than others.
blaenk: The general recommended source for beginners is Learn You a Haskell (also freely available online)
This one seems to commit the IO-monad-is-about-ordering-evaluation sin, but not the others.
That and Real World Haskell
elliott: got it, have you seen and can comment on the laziness one? http://en.wikibooks.org/wiki/Haskell/Laziness I used that to get a (I think) better understanding of lazy evaluation
merijn: thanks yeah, I was using that and real world haskell, I just figured I'd check the wikibooks out for more in-depth information, guess not then
that page looks good at a glance
cool
Better than the average explanation of laziness anyway :)
mauke: http://hpaste.org/80490
there is no ambiguity. You claimed you didn't have to include export to export a variable in .profile. You do.
yeah laziness was bothering me a lot, it was generally hand waived everywhere I read (oh thanks to laziness blah blah) and I wanted to understand it a little better
blaenk: Minor nitpick is that it says "laziness is how you implement non-strictness", but usually the two terms are used for different things
anyway, done with this nonsenes for real now
pnielsen: I don't understand your point
that's just a chat log
blaenk: Usually laziness means "expressions are *never* evaluated more than once", whereas non-strict means "expressions are only evaluated when necessary"
mauke: I just have to assume you are trolling
merijn: ?
Non-strictness is about semantics; laziness is a non-strict evaluation strategy.
I can't believe you really don't understand the meaning of those sentences
pnielsen: or you could explain the contradiction you see because I don't see it
laziness is a way to implement non-strictness
elliott: Hmm, maybe I've been taught the wrong terminology myself >.>
mauke: you said "what if it [an env var] wasn't already exported?". I said "then you would need it [export]". You said "no". You DO need "export".
Are there other ways to implement non-strictness than lazyness?
merijn: Call by name is an example of another non-strict evaluation strategy
Ah...
which is just laziness (call by need) but you re-evaluate (no sharing)
pnielsen: that does not follow
pretty terrible in practice :)
like, at all
merijn: does this not make sense?
"what if this sandwich doesn't come with ketchup?"  "then you would need extra ketchup"  "no"
I don't like ketchup
elliott: Hm thanks, that's a really good example. It seems really simple to distinguish the two things (lazyness and strictness) now.
frerich: In practice Haskellers often mix up the terms and use "laziness" when they mean "non-strict" and vice versa :(
okay, this is my last attempt. you said, "what if [an exported env var] wasn't already exported? [meaning that an export statement did not precede it]. I said that "then you would need a leading export statement [in order to export it]. You said no, but in fact you do.
pnielsen: you are assuming you want PATH to be exported, mauke doesn't
Non-strictness just means you can write non-strict functions (functions f such that (f undefined) isn't undefined) and they'll work properly.
Laziness is an implementation strategy that gives non-strictness and also the operational nicety of sharing.
elliott: That would certainly explain my confusion, because at some point I thought the two are synonymous but then again somebody said they are not - at which point a long rant emerged and I lost track of things. :-)
frerich: generally you won't need to care about the difference, since laziness is the only way we do non-strictness in practice
frerich: Don't worry, if you let the channel cool for a few hours you can set off the exact same rant and try to follow it agian. :P
srhb: Haha that's so true! :-)
frerich: it's mostly a type error to say non-strict in place of lazyness or vice versa, because one is about denotational semantics and the other is operational
srhb: haha
pnielsen: the "... in order to export it" part was only in your head
we were talking about exporting env vars. rofl.
yes
or not exporting env vars, in this case
has someone written a scraper or crawler in haskell yet?
snowylike: I started working on one at some point, and I refuse to believe no one else has done that\
mauke: i think you could've made more explicit sooner that there was such a hidden assumption in pnielsen's reasoning which you didn't accept
merijin: i haven't found one atleast
Saizan: I wasn't sure that was what's going on
that's why i ask
snowylike: http://adit.io/posts/2012-03-10-building_a_concurrent_web_scraper_with_haskell.html maybe?
mauke: it's worth mentioning if you suspect it might be
snowylike: Anything specific you're looking for?
Saizan: to me it looked like a non-sequitur, not reasoning-with-hidden-assumption. I was just confused
donri: thanks, i'll take a look at it
mauke, Saizan: anyway, sorry. This was really silly. Good night :)
merijin: not really, just some very diffuse ideas i can't get to solidify yet
http-conduit + html-conduit/xml-conduit makes a good basis for writing a scraper
well, no
native german
That's counter intuitive
why?
First time I see a German speaker butcher a ij digraph :p
merÄ³n
It's normally the silly Americans or British that get confused :p
well
okay
mauke: that's what non-sequiturs usually are ime, but i guess it's not always easy to imagine what the assumption could be
80% of what i read is written in english
and it's been that way for about 5 or 6 years, so
mauke: Props, I don't even know there was a unicode character for that :p
Now I need to update my mail address to make everyone's life impossible...
http://dl.dropbox.com/u/41152078/unicode.html?q=latin+ligature
(this isn't even my ARABIC LETTER MEEM FINAL FORM)
oh! Now I can use proper ï¬€ and ï¬ ligatures in typing!
i like it when people use Unicode
because then all i can see are little boxes
I installed ghc-mod-1.11.1, which installs with Cabal-1.10.2.0.
I'm using unicode right now
okay, not only boxes
damn my tendency for unnecessary hyperboles
and those "boxes" are called pixels :-)
they're not pretty *enough* to make it worth all those times when they don't render on e-reader etc.
if its not in dejavu mono then it aint acceptable
Is there a library for drawing graphs?
epta: Won't dot and graphviz do it for you? It's the standard solution anywhere, I think.
unless you mean charts
Then there's plot I guess.
diagrams
epta: What do you need in your graphs?
srhb: actually I'm looking for some complete solution like getting pair of connected nodes and return image with this graph
(but that's a bit low-level, you need to build graphs on top of it)
epta: That's a little vague, but I don't think you'll find a combined solution.
:t (&&&)
:t arr id
arr id
y)
y)
@hackage json
@hackage aeson
@hackage reflection
So aeson is a better choice than json?
allsystemsarego: aeson is faster, and (because) it works with Text
@hackage arson
Huh? Aeson, right?
@hackage yaml
@hackage ..
does anyone know of a decent enough concurrent map or hashmap implementation in any package?
@hackage unordered-containers
concurrent?
ozataman: Any data structure can be made concurrent in Haskell by the use of MVars, I guess.
srhb: for sure, I just wanted to see if there's a way around rolling my own
ozataman: I donâ€™t think it exists yet.  there was a GSOC for lock-free concurrent data structures
iirc
It's a bit cheating though :P
guess I'll have to roll my own using stm
well of course you can stick everything into a MVar and access it one-by-one but thatâ€™s inconvenient
yeah, I have done TVar (Map k (TVar a))) before
I bet there are implementations buried in various packages
I see many times that functions like fold, map, scan, length ecc. are rewritten in packages with their own implementations
is that because those are not defined in any class?
No doubt. You should probably release your awesome concurrent Map. ;)
Lethalman: There's a foldable class that can be used, in that case each package would make an instance for their data structure.
there's also lens.
Lethalman: even if they were defined in the class they would still be rewritten in packages with their own implementations
that is, after all, the point of a class.. that things have their own implementatiosn.
quicksilver, true, but aren't classes made for that after all?
no.
classes are made for overloading.
so the question is, do you ever want to write "length" and have it automatically deduce which type you wanted?
srhb, right, what's the main reason why it isn't that way for all packages? Foldable came later?
in fact, fold + length are basically provided by Foldable
and map is provided by Functor
The fact that you see many foldrs that are not Foldable instances is historical, Prelude isn't very generalized. Some people think it should not be, in order to not confuse newbies.
not sure about scan, you need traversable for that.
srhb, ah, and is that limiting somehow?
Kind of. It's less general.
the fact is that you can't write (Foldable f) and expect something not Foldable to work, you have to rewrite the function for that specific type, right?
or you could just write the instance.
quicksilver, right
in practice it doesn't seem to be a very common problem (wishing somethign was an instance of Foldable)
Lethalman: It's no difference from the fact that fmap only works on things that have functor instances (ie. a definition of fmap)
quicksilver, just curious
karma jeltsch
??karma jeltsch
preflex: karma jeltsch
Preflex is gone.
@karma- jeltsch
and for the things that aren't/can't be Foldable, you can still write your own Fold. :p
or (better) Traversal
Isn't Traversable just Foldable and Applicative?
Jafet: What was your reason for issuing this command?
I'm talking about lens.
Ah.
@karma+ jeltsch -- happy? :P
you can't define a Fold without depending on lens.
but you can define a Traversal.
Nereid: can you link an example? I'm suddenly unsure of what a Traversal is.
srhb: As far as my â€œkarmaâ€ is concerned: yes. I still wonder what Jafets reason for lowering it was.
traverse is a Traversal.
:t traverse
jeltsch: Showing you your karma and command.
srhb: But â€œ-â€ doesnâ€™t just show it, right? It decrements it.
over traverse (+1) [1..5]
jeltsch: Right.
Is there a way to show it?
@karma jeltsch
but some things that are not traverse are also Traversals.
Ah, okay. Thanks
:t both
over both (+1) (1,2)
jeltsch: Yep.
:t over
:t over both
Huh..
Okay.
over just sets f = Identity, more or less.
f (b, b)
get rid of the f:
(b, b)
runIdentity $ both (Identity . succ) (1, 2)
srhb: time for you to read about lens, I guess.
@where lens
Nereid: *growl* ;)
:)
oh.
here's that talk about lens. http://youtu.be/cefnmjtAolY?hd=1
Yep, watched it yesterday. I need to watch it again.
ah.
But I didn't know lens.github.com -- that looks very nice.
2 hours \o/
It's quite good. The sound is slightly annoying at times, but it works out.
:t both
it is pity, YouTube can not reach.
what audience is that video for?
general haskell audience I guess.
I know what monads, applicatives and arrows are but I'm not very experienced with them
Lethalman: living, breathing, and preferably sentient ones.
I don't think you have to worry about those too much.
helps to be familiar with guys like Functor, Foldable and Traversable
But it's not necessary. The types are easy to decode in the parts he uses to lead up to each lensy thingamabob
It dives deep fast, but in any case, start watching and see how far you get. We're here to help.
yes, starting now :)
I think I prefer the version of the lens laws that are the setter laws and view l . over l f = f . view l
can anyone help me http://hpaste.org/80492 how can I run this st action: `run someAFun` ?
:t runST
:t runStateT
why is that not a ReaderT?
mauke: there's no reason, I'm just making some tests for learning purposes
I don't think that code can work.
Nereid: why ?
where are you going to get the STRef from?
hmm.
maybe it can.
:t newSTRef
Nereid: `run someAFun` is well typed
sure, that's not the problem I was thinking of.
it's type is `ST s (AState s)` I think I'm missing a forall s. here
:t runST
otherwise it's same with runST's parameter
:t newSTRef ?x >>= runStateT ?m
ok, sure.
this would work.
what would work ?
what I just wrote.
inside ST, make your STRef and then use runStateT or whatever.
I'm already doing that in `run` ?
right.
should work then, just use runST.
Nereid: the problem is `run someAFun` works but `runST $ run someAFUn` doesn't
what about runST (run someAFun)?
a`
oh.
no, you're trying to extract a STRef out of ST
yeah that can't work.
mauke: wait
you can't leake the s out.
leak.
hmm
to run a ST s a, the a can't have anything to do with s.
so if you could make it like a ST s Int, then that would work.
which means you'd have to modify run. (and its type.)
I should probably read the code properly before answering.
how come AState isn't a newtype (or perhaps even a type synonym)?
Nereid: I can make it so, I'm just testing stuff
sure.
how come I'm not in bed? :)
bye.
bye and thanks
I should leave for 10-15 minutes and I still don't understand how can I get that int out of ST monad and return
brb
how about readSTRef.
hi
hi
poll: Data.Graph vs. FGL - pros? cons?
for some reason happstack still feels like the most practical web framework
mm_freak_: maybe it is?
Yeah, it's so easy to dive into.
I do hope Yesod gets more approachable given time. I love the safety it gives you.
allsystemsarego, I used Data.Graph a while ago and I found it to be simpler and I think more up-to-date than FGL
allsystemsarego: I'd use Data.Graph if it does what I need.
srhb: i don't see any additional safety except for compile-time URL overlap matching
mm_freak_: Right, but that's a pretty big deal.
srhb: the overlap matching?  i don't think i've ever run into serious issues with overlapping URLs
allsystemsarego: Data.Graphs is simpler than FGL, but also simpler than FGL. :-)
Graph*
mm_freak_: Then I guess you're all out of cons for Happstack. :)
easy integration of persistent is probably a plus for yesod, but honestly i didn't find persistent practical to begin with =)
even in my yesod times i used acid-state or HDBC
allsystemsarego, Data.Graph doesn't have labels
Vertex manually
mm_freak_: Persistent scares me, the TH is a bit too deep for me. I think acid-state is somewhat easier to deal with in my mind.
I remember having a Haskell "aha!" moment reading the 4-line implementation of dijkstra's algorithm in Data.Graph :)
that's just because it's opaqueâ€¦  that would be fine, if you wouldn't hit the ceiling so quickly
also, GraphViz integration!
mm_freak_: What do you mean by hitting the ceiling?
mm_freak_: But yes, it is indeed because it's opaque. And because TH is scary.
srhb: when the opaque interface gets in your way, like when you need to do something the opaque interface doesn't provide or even allow
Ah, yes.
I thought that was hitting the stage floor
TH isn't that scary thoughâ€¦  i've been thankful for its existence a number of times
just imagine having to write SafeCopy instances or lenses by hand =)
I think it's a little scary. It doesn't look enough like Haskell, and I don't know if I'm doing something completely unsafe.
mm_freak_: Yes, I know. That would be very annoying.
I just wish there were a better solution, but I have no idea if it's in any way possible.
i think the reflection library proves that this is possible, but you would have to do all the computation at runtime
and it would depend on other ugly things like Typeable and Data
Isn't Typeable getting less ugly?
I thought some things were going on with it.
not that i'm aware ofâ€¦  also Typeable itself isn't that ugly except for its fixed rank
Meh. This topic gets too deep for me very quickly. Most of my complaints are "this feels dangerous" and "I don't know what's going on"
So not very useful criticism.
mm_freak_: not considering snap?
reflection doesn't have Data constraint (any more)
Is Data bad? I don't remember hearing about it.
Data reflects the representation of data types into haskell
It's more of a "guns kill people" thing
I don't like things that allow me to shoot people without a big fat unsafe* stacked in front.
Data is implemented in plain haskell
What's scary about it then?
Nothing. It just makes some abuses more convenient
*boggle*
Okay.
But Data by itself is type-safe
I spend too little time on the type level to understand this, probably.
reflection doesn't have Data constraint?
hi
What does "reflection" refer to there?
Does it?
@hackage reflection
AFAIK no version of that reflection trick has involved Data
Okay
both the paper and the package have always been able to reflect arbitrary vlaues
elliott: i've been using snap before
I thought the paper had to manually reflect integers by encoding them in binary
how do i perform pattern-matching for the Show class, for a tree-like structure? lines 22-24 in http://ideone.com/7asAY1 were my first attempt at it, but huggs says No member "==" in class "Show"
(aka Data)
?
I don't see what that has to do with Data, but the paper uses the trick of turning StablePtrs into integers.
and you can make a StablePtr for any Haskell value
Clearly I should actually read the paper.
dextr: your syntax is wrong
dextr: you should have something like: show (Add a b) = show a ++ " + " ++ show b
oh, i see :x
thanks
just normal pattern matching
'reflection' in this context just means that you can derive class instances at run-time
write the pattern in place of the argument you are trying to match
no == needed
now it looks like you're trying to define an operator ==
in other words, you could /compute/ the SafeCopy instance when the application starts
but that requires a Data constraint
originally i only had (Value a) = show a, but that failed with "a" multiply defined, so i thought i needed to be more explicit
dextr: you need to mention the name of the function you are defining, not just the argument
thus "show (Value a) = show a"
definitions inside a type class instance are just like definitions of standalone functions
what does "Cannot justify constraints in explicitly typed binding" mean?
so IO is not just ST RealWord, right ? I'm wondering if I can call ST functions inside IO functions (by making s variableRealWorld)
dextr: not sure, but if you put the offending code somwhere we might still help
edwardk: ping
osa1: i think there's a stToIO function somewhere
:t stToIO -- osa1
ok, one sec .. but the code is relatively big (it's the i/o part) :x
You can "lift" any ST action to IO.
simpson: by stToIO ?
dextr: I think that's the message that hugs gives if one of your type variables needs to have constraint (like Show a or Num a for example), but you didn't give it one in your explicit type signature.
osa1: Yeah.
osa1: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad-ST-Lazy.html#v:stToIO
I need a fast, strict and dense concatenable structure. Which one should I use? Is Data.Sequence still good?
http://ideone.com/ufWbEz - the constraint is there i believe, the offending line is the first one (according to hugs)
dextr: What's the constraint that Hugs says is missing?
http://ideone.com/ZLGXdP <- this is the message
http://ideone.com/pVx0AX <- this is what ghci (with -XDatatypeContexts) says
dextr: Assuming the error is actually on line 12, 13 or 14, I think the problem is that you don't give a type to val, so val's type is just "b" and doesn't have a Group constraint.
aleator: do you mean that concatenating should also be fast?
val is the value that is read in from the console - that does not need to be a Group
(in fact it'll be a Double)
dextr: Of course it does. You try to put it inside a Value.
And according to your own definition Values can only contain types that are Groups
oh
so i need to change line 32 to Value Double?
Maybe, but then how would an  Expr Foo  be different from an  Expr Bar?
it's time to learn me a haskell :l
what do you men sepp2k ?
Because if you change it to Double on line 32, there won't actually be any as contained anywhere inside an Expr.
well, an expression is a tree, and the leafs are concrete values
is that wrong?
No, but if the leafs are the same type of value no matter which type argument you chose, then why have a type argument at all?
Or asked differently: How will the value of a affect your Expr?
oh, ok - yes, leafs can actually of multiple types
but as i first step i wanted to solve this for just one type :x
Then you need to remove the type parameter. Otherwise you're going to end up with lots of ambiguous type variable errors.
Of course that also means that you can get of your Group typeclass altogether.
hm.. ok then, lets try it all at once (that is without removing the type parameter) ^^
how would i express in line 11 that val may only be of a specific type? casting? val::Double?
Yes.
You also need to add an instance Group Double.
Otherwise you won't be allowed to put your Double in an Exp
ok
dextr: it's not casting: annotations cannot change type
what is it then?
just annotation
you're specifing what type it should be
oh, ok
dextr: Btw: Your calcInteract function doesn't use its argument.
hm.. if it's not casting, then what would happen if i wrote val::Group?
 /away
dextr: You'd get an error that Group is not a type.
classes and types are not the same thing?
about calcInteract - i shortened the code, to make it more concise, this is the full code: http://ideone.com/6ShgAl
No. A type can be an instance of a type class (or multiple ones even), but a type class itself is not a type.
a  is a type, but Group is not.
i see
what is the proper wy to make  let newExprs = [(Value val)]  generic? that is work with both doubles and other types?
*way
marekw2143 pasted â€œRandomâ€ at http://hpaste.org/80496
hello, why following doesn't compile:^^
dextr: It would work with other types. The problem is that read needs to know which type to read.
dextr: you have to decide which type or types you want it to work with
marekw2143: [Num] ?
definitions exist, is there any way to let the runtime system decide automatically which of the specified As it should use?
fmap: okkok, I just know htat Num is typeclass and not concrete class
dextr: Automatically based on what?
but using ([Int], StdGen) produces another error
based on what the input (i.e. the read line) is compatible with
Oh wait... runtime system? No, types are checked at compile time. No typing decisions are made at run time.
couldn't match expected type 'io t0' with actual type `([Int], ())`
e.g. string, double, int, etc.
dextr: That's not how read works.
main is an IO action
marekw2143: You can't sequence that pure value like that. It doesn't make sense.
dextr: There are different read functions for different types (some of which accept the same input or overlapping input). The compiler chooses which read function to call at compile time based on the type of the result.
(Or non-IO action, rather)
marekw2143: If you printed it, it would make sense
marekw2143 pasted â€œRandomâ€ at http://hpaste.org/80498
ok, so then for different types, the code needs to be changed? (discadring the possibility that only strings are read in and some self-written function is used to determine types at runtime)
marekw2143: It's still not an IO value. <- does not make sense on a non-IO action in the IO monad.
marekw2143: you could use let a = ...
dextr: No, you can make it generic, you just need to decide how.
dextr: That is, for example you could decide that if the user hits "n", the type the user should enter should be the same one as the type of the exprs list.
srhb annotated â€œRandomâ€ with â€œRandom (annotation)â€ at http://hpaste.org/80498#a80499
srhb: thanks
I'm just haskell newbie
marekw2143: Sure. :)
marekw2143: It's the same reason that 2 >>= foo -- does not make sense
Of course this is just a complicated way of writing "main = return ()" :p
how long does it take (on average) to be able to write simple web server in haskell, having 3 yr's of imperative experience (incuding python) ?
Right.
marekw2143: A week or two?
I mean, for something very simple.
hm.. is there a way of enforcing val to be of the same type as a?
srhb: I think he meant "how long does it take to learn haskell well enough to do that"
merijn: Am I being optimistic? :P
I think so
Hm.
which i guess is the same thing you suggested sepp2k
2 >>= const $ return 1
I think it took me about 4-6 months before I was comfortable writing haskell and probably another times that before I really got into the needed stuff to do something like a webserver nicely
Hafydd: 2 ain't no monad!
Well, Int.
dextr: You can use the ScopedTypeVariables extension in GHC and then use read line :: a.
marekw2143: are you talking about actually writing a webserver yourself?
dextr: Or you can use the asTypeOf function from Prelude.
Granted, I was a bit slow, but I'd say 3-6 months before you're capable of writing a semi-decent webserver? (From zero haskell knowledge, that is)
srhb: it is in ghci.
merijn: Ah well, I did not mean semi decent. I meant responds to HTTP requests. :P
use snap
Or something like that.
Hafydd: What?
use happstack ;)
basdirks_: yes
t7: That's a bit orthogonal to the question, isn't it?
Well, I'm sure you could do weird thing with the function instance..
does he mean write a web server or use a web framework?
t7: The question wasn't "what do I use to make web apps" it was "how long does it take to become competent enough to write something *like* a web server"
Well, nevermind, I suppose it isn't, but this does work:
do { 2 }
i mean to write server to handle HTTP requests with assumption that writer knows HTTP protocol
I suppose that's because of ghci's hacking to make the REPL work.
:t do { 2 }
marekw2143: I'm gonna go with my original 3-6 month estimate (maybe even more if you're not pushing very hard to learn/get better)
Hafydd: `do 2' works because that's how do-notation works
 Hafydd: do { e } := e
Wrong symbol, but.
marekw2143: On the other hand, I'm quite confident saying that I can (now) develop one in haskell in significantly less time than I could in any other language
how is asTypeOf different from ::Type?
Hafydd: So that introduces no operator from Monad.
:t asTypeOf
do { foo }
:t 2 `asTypeOf` (+)
2 `asTypeOf` (+) $ 3 4
what does that last line do?
That explains it...
Hafydd: :)
dextr: Mine? Evil, weird and confusing things :p
:t asTypeOf
yes merijn
:t asTypeOf 2
:t asTypeOf 2 3.4
ah, cool
dextr: asTypeOf is different from :: in that you don't need an extension to refer to a.
why does it have that instance?
1 2
mmaruseacph2: Because you can do funny things like "sin^2"
merijn: didn't that get removed?
:t sin
:t sin^2
:t sin^2
dextr: That is, without extensions, just writing :: a would not work, because by normal Haskell rules, each type signature has its own scope, so the a in :: a would not be the same a as that in your toplevel type signature.
sin^2 .5
(sin^2) .5
(sin^2 + cos^2) 0.5
(sin^2) 1
hmmm
Peculiar
merijn: NumInstances were removed
dextr: But  read line `asTypeOf` valueOfTypeA  will work because it simply forces the two arguments to be of the same type.
startling: No, because otherwise "sin^2" would be a type error, no?
a) constraint
ah
anyway, it's cool
a) or not
mmaruseacph2: But was horribly confusing to newcomers, which (I guess) is why it got removed
You could still implement it yourself, if you want to
(sin x)^2 + (cos x)^2
merijn: thanks, looks good
 btw, what features do you think are good for a talk given to non-haskellers interested in web design and open source?
IO () in the function signature)
I'm thinking of presenting some Yesod/Snap/Happstack
mmaruseacph2: Should it be web related? Or just anything cool and haskell related?
but I wanted to know if there are some hints on things to focus about
web related for this edition
Then I'm out of suggestions :p
I think it's quite natural to extend numerical operation to functions on numbers, which are just abstractions of numbers themselves.
there will be a second one in three months
I wouldn't use Yesod though, the TH voodoo in there scares me and I'm used to complicated haskell :)
:)
Hafydd: Oh, sure. It's quite natural, but you have to admit you can see how things like "sin^2" and "1 2 = 1" might be confusing to newcomers trying simple example code that should just produce an error ;)
I suppose so.
The former is okay, but the latter is a bit demented.
Hafydd: Sure, but Num demands a fromInteger function
Maybe if there were a Num-like class without fromInteger?
There have been many proposed refactorings of the Num hierarchy, but I don't see it changing in the forseeable future
I tried all three - yesod, snap, and happstack
yesod felt huge and took ages to compile
hi cale
with snap, I didn't quite feel at home with the philosophy - I know very well how HTTP works, I don't want it hidden from me, I just want convenient access and full control
happstack fits my way of thinking best
If bad point-free is point-less style, this is do-not style: double x = (do { (*) } $ do { 2 }) $ do { x }
what's the difference between (:) and ++ ?
:t (:)
:t (++)
Well.. Except the monoid instance
dextr: (:) appends one element to a list of those elements, ++ concatenates two lists of the same type of elements
ah, ok
so (:) appends at the end?
No, sorry. Prepends
1 : [2,3]
:t (Data.List.++)
([x] ++))
[1] ++ [2,3]
searchting for those operators in google seems impossible :\
dextr: Use hoogle
dextr
use hoogle
or hayoo
oh, ok
@hoogle (:)
Well, that didn't go very well.
I still don't know what's the actual difference between the two
and why there are some things found only by one of them
hayoo searches Hackage
is there a Microsoft themed haskell search enging: Hing ?
hoogle searches base, I believe
is it polite to tell the german CEO of a company you're applying to that the english tagline which they have in their logo uses bad grammar?
hoogle searches base and some other packages iirc
osfameron: It's called Hang.
hoogle searches a bit more than base
osfameron: (No, sorry, there isn't)
heh
mmaruseacph2: hayoo searches all of Hackage; hoogle searches a more limited subset but it can also search by type (which hayoo can't)
byorgey: Hayoo can't search by type? What?
i thought hayoo could search by type?
byorgey: thanks
oh, hmm, so it can
ah, but hoogle's type search is better
hayoo only finds exact matches
yeah
hoogle finds types that are "close", or more specific, etc.
byorgey: less specific.
perhaps it finds less specific things too, but I stand by what I said.
what you said is fine
[a]
I was really just remarking that less specific is often the more useful :)
since your original search is then an instance of it
fair enough.
Well there goes another 1.5 hours because of mutable data :(
haskell has changed the way I code
and I say this by comparing code written three years ago to code written a few weeks ago
same language, same project
Changed for the better, I hope!
neutrino_: probably better off not if you are applying
neutrino_: you can submit it anonymously and then claim credit later after you're hired
whois amiri
whois PhiRod
philed: yup, for the better
imperative code gets written in more testable way
yitz: heh
yitz: i think i'm not applying anyways :p
When can we encode laws into classes?
[a]
srhb: is it possible to statically check laws?
I'm guessing in general no?
statusfailed: I don't know. Hence the question. Is it possible, and if so, what do we need and when do we get it. :-)
In general no, probably, yes.
srhb: seems like it would make classes more inflexible, which might be a bad idea
after all, sometimes people do ignore the laws
statusfailed, depends on the law
sure, but in general it's not gonna work right?
srhb: for most laws you would need a dependent type system.
^ yeah
byorgey: why?
Agda and Coq can have structures/classes with statically declared laws.
I need to pick up agda
fmap: well, I suppose just to *declare* the laws you don't necessarily need dependent types.
Given dependent types, is it possible to statically check laws?
(for an arbitrary law)?
but in general it's hopeless to have the laws automatically checked
you need the programmer to provide a proof
yes
Right, I meant to have automatic checking.
like QuickCheck?
No, real lawfullness.
and the most natural way to do that is to have the law expressed as a *type* where the programmer has to provide a *value* of that type, which by the Curry-Howard isomorphism corresponds to a proof of the law
but in that case such laws-as-types must be dependent, because the need to mention type class methods
So you must think of a type representation of your law. That sounds tricky.
not really.
if the proof is obvious enough, you can let check it automatically.
byorgey: can you give an example? If it's not too much to ask.
expressing the laws as types isn't the tricky part, really.
srhb: if you have dependent types then you can include arbitrary value-level stuff in your types.
srhb: it's hard to give a good example in Haskell because it isn't dependently typed =)
Pseudo-syntax would work :)
(Well, maybe!)
yeah, example would be nice
...and also _|_ gums things up.
take a look at Agda and Coq if you are interested in this approach though
I've done a bit of coq (first 3 chapters of SF) but still don't understand why you need dependent typing there
I'm mostly interested in what it would look like for Haskell (in a fuzzy manner)
srhb: here's a link to part of the Agda standard library. take a look at Semigroup: it declares an equality method, a product method, and a field called 'isSemigroup' which is a proof of type  IsSemigroup
http://www.cse.chalmers.se/~nad/listings/lib-0.6/Algebra.html#1
IsSemigroup is here: http://www.cse.chalmers.se/~nad/listings/lib-0.6/Algebra.Structures.html#640
a; mappend_mempty :: forall a. mappend mempty a = a; ...}
it has three fields, which are proofs that the equality is an equivalence, that the product is associative, etc.
here mappend_mempty is a dependent type: that "a" is not a plain type but instead a value (of type, err, "a")
srhb: meh, ignore me, pay attention to elliott  =)
  mappendAssociative :: forall (m0 :: m) (m1 :: m) (m2 :: m). mappend (mappend m0 m1) m2 = mappend m0 (mappend m1 m2)  -- perhaps
[[a]]' so that 'groupSucc [1,2,3,4,6,7,9,10,11]' yields '[[1,2,3,4],[6,7],[9,10,11]]'. Does anybody have some nice idea for how to implement this without using folds?
frerich: I don't think you can?
well you can always write out the recursion by hand :)
Well yeah, without manual recursion as well, of course. ;-)
byorgey: that may be the least wise advice anyone has ever given :)
I think the straightforward recurse-and-collect-into-accumulator solution is the best
*boggle*
elliott: hehehe
I see Agda stdlib code is as accessible as ever, though
"âˆ™ Preservesâ‚‚ â‰ˆ âŸ¶ â‰ˆ âŸ¶ â‰ˆ". obviously.
frerich : with what constraints on `a' ?
elliott, byorgey: Thanks to you both. Perhaps I really do have to do Agda or something in order to understand this. Neither explanation seemed very enlightening. :P
you can probably do it with some magic from the split package, but that probably boils down to the same thing eventually
merijn: One idea I had was to work on 'zip xs (zipWith (-) (tail xs) xs)' so that you have the deltas and then work with that.
srhb: try reading "The Power of Pi"
srhb: Well, mappend_mempty is a type that says things about values, because you're giving a law as a type. That's what dependent types are all about.
Now, you *could* bolt an unrelated language for stating properties about Haskell code in
...and an unrelated language for proving said properties
ski: No particular constraints given, I personally tried to work with just Eq and Enum but if you have some fancy Applicative trick or something, I'd be interested in that as well :)
srhb : did you see the `mappendAssociative' example ?
...but it'd be an awful waste when you could reuse the type system you already have, especially as you want it to be constructive just like a typed programming language, etc.
ski: Yes, I'm looking at it right now.
u - v == x - y) . zip [0..]' :-)
merijn: So apparently it *is* possible.
what does mempty mean in the definition of mapend_mempty
normally that just shadows the name, but that's not what's going on here is it
frerich: <Obscure technical argument about how you could trivially translate that to a fold>
srhb : it means the usual `mempty' member of `Monoid'
So it's actually a pattern match on whatever mempty is for the specific instance?
not a pattern-match, but yes, it refers to whatever `mempty' is for the specific instance
Okay.
Hmm.
ski: `=' means they are same type?
fmap : no, that they are the same value
mempty :: Any
  newtype Any = Any {getAny :: Bool}
so with `instance Monoid Any' we have `mempty = Any False'
so in that case `mappend_mempty :: forall (a0 :: a). mappend mempty a0 = a0' really means `mappend_mempty :: forall (a0 :: Any). mappend (Any False) a0 = a0'
and then it would depend on how `mappend' is defined
perhaps it's defined as
  Any b0 `mappend` Any b1 = Any (b0 || b1)
or perhaps as
  Any False `mappend` a1 = a1
  Any True  `mappend` _  = Any True
Any False
right
ofc :S
in the latter case, `mappend (Any False) a0 = a0' in the law could be simplified by the system to `a0 = a0', which is trivially true
srhb : does this help any ?
that looks like coq really
ski: I think so... It's like it's almost within my reach, but not quite. :P
ski: so that's value level equations lifted to type level?
hi there, I recently installed the latest version of ghc (7.6.1) from source, but it doesnt work particularly well with a lot of old packages, so I want to switch back to 7.4.1 (the one provided by ubuntu's package manager). How do I do this? I tried running apt-get remove ghc, then installing ghc via synaptic, but after the install it still shows the version number as 7.6.1
ski: what I don't understand is how that relates to "to prove something you need to provide value of that type"
mempty?
Or what. Maybe I'm still lost :P
mempty :: Sum Integer
mempty :: Product Integer
srhb: I apologise for the ambiguous syntax, though it's mostly Haskell's fault :)
fmap : i'm not sure what exactly you mean by "value level equations" here
elliott: I know. Thanks for trying. I'm being dense again. :P
Haskell hasn't got dependent types -- so it never needs to worry about wanting to reference "mappend" -- so it willy-nilly takes up the namespace of all lowercase sequences for type variables
Right.
Is there something that takes [(m a, m b)] and gives me `m [(a,b)]' ?
and we have no notion of type-level equality ("=") though you can define it with GADTs: data Equal a b where Refl :: Equal a a
-- for this to work for that proof, you need the ability to pass Equal two *values*, not just two types as you can in Haskell
(and get a type back)
fmap : anyway, in case we really have dependent types, rather than a separate language for (stating and) proving laws, then we need to define a value `mappend_mempty' when defining `instance Monoid Any'
Haskell is not the ideal setting to explore things like this
ski: well, mappend is defined on value level with equations, and we use them on type level
elliott: Hmm, okay.
fmap : the `mappend mempty a0 = a0' in the signature for `mappend_mempty' is not meant to be read as a *defining* equation, but as an equality which may or may not hold (but we need to prove it holds, here)
anyway, given
  mappend_mempty :: forall (a0 :: a). mappend mempty a0 = a0
which in this specific case amounts to
  mappend_mempty :: forall (a0 :: Any). mappend mempty a0 = a0
we need to define
  mappend_mempty = ...
where `...' is a proof of  `mappend mempty a0 = a0'
m [a]
the latter is "sequence"
fmap : how this proof will be written depends on the language we use for proofs
it might perhaps be written like
m (a, b) = uncurry (liftM2 (,))
:t sequence . map (uncurry (liftM2 (,)))
:t mapM $ uncurry (liftM2 (,))
ski: what's the right term to substituting `mappend mempty a0' with `a0' given `Any False `mappend` x = x' then?
s/to/for/
Doh, okay, I confused myself. I was trying to understand mappend_mempty as a proof, but of course it's the law. And then the instance provides the proof?
  mappend_mempty = {= mappend mempty a0
     ={ DEF mempty }= mappend (Any False) a0
    ={ DEF mappend }= a0
                    =}
why is getChar strict but getContents not ?
osa1 : `getContents' is intended to be lazy
srhb : yes
perhaps using a syntax like above, perhaps in some other way
The syntax makes little sense to me, but I guess that doesn't matter much.
The Any False is the dependent bit?
Hm, that's a bit vague
The equivalent of "mappend_mempty = Refl" should work there in any self-respecting dependent lang, of course
but you will have to do something like what ski said (for vague definitions of "something like") for more complex proofs
=}'
elliott: thank you
hi, I am trying to learn how  to downgrade my ghc version from 7.6.1 to 7.4.1. 7.6.1 is the version i have installed from source, but I want to go back to the version in ubuntu's package manager. Can anyone help?
srhb,fmap : "Equality proofs in Cayenne" by Lennart Augustsson in 1998 or 1999 at <http://web.archive.org/web/20090426033216/http://www.cs.chalmers.se/~augustss/cayenne/eqproof.ps>
might perhaps be interesting
craigInnes: So install GHC through Ubuntu's package manager?
fmap : "what's the right term .." -- hm, not sure, perhaps "(replacement) by definition" ?
ski: Thank you :)
craigInnes: You did install GHC 7.6.1 through the package manager as well, right?
srhb : Cayenne was sortof a predecessor to Agda1, btw
for more info on it)
mSSM: No, this is the issue, I installed 7.6.1 from source as it was not available through ubuntu's package manager
craigInnes: That does not make any sense.
craigInnes: You mean 7.6.1 was not available from Ubuntu's repositories?
7.6.1 is pretty new, I wouldn't expect it to be in all the repos yet.
elliott: I think he make configure install'ed it
? Sure, that's what he's saying.
mSSM: Apologies, I am a bit of a n00b when it comes to linux related things. Ubuntu's apt-get / synaptic shows the latest version as 7.4.1, but you can download the latest version 7.6.1 from ghc website
to clarify, i did go the configure/make install route
Ok, because if you had installed a .deb package, that would have made things easier. ;)
I think the GHC distributions let you "make uninstall".
So perhaps try that?
craigInnes: Try what elliot suggests; otherwise track down all files make install put into your system, and delete them by hand.
craigInnes: Then go through apt-get
craigInnes: Note for future reference: never dump anything onto your system unless it's through the package manager.
mSSM: I am learning this the hard way it seems. I was advised by someone else on this channel to install from source and that it wouldnt really be much trouble.
mSSM: So it doesnt seem to be able to find a make uninstall command. What files should I be trying to track down? ones in usr/local ?
craigInnes: He should have warned you that you only do that if you really know what you are doing.
craigInnes: Are you sure you're in the directory you ran "make install" from?
If my recollection is right and there is such an uninstall target then it'll only work from there.
(By the way, why are you downgrading? Maybe there is a simpler way to solve your issue)
elliott: I am the same directory from which I make installed and configured
craigInnes: I honestly don't know. You could check the make-file to see where it puts everything. But usually /usr/ is the correct place to look for.
autotools-based systems like GHC's usually default to /usr/local
Well, that's smart and a good thing.
elliott: I'd love to use 7.6.1, but cabal-dev won't work with it.
elliot: I am downgrading because I am running into errors when installing various libraries which I did not encounter with the old version of ghc. And was told this was because these libraries hadnt caught up to the latest version
Unless I use the git version.
craigInnes: http://www.mail-archive.com/haskell-cafe@haskell.org/msg32572.html has a list of locations you probably want to get rid of
craigInnes: in fact
craigInnes: have you installed anything else from source?
elliot: No, this is a bit of a first time experience
if not, you can probably just blow away everything in /usr/local -- rm -rf /usr/local/* -- please make absolutely sure of this before running that command :P
if you do "$ ls /usr/local/bin" then if the output is all GHC-related stuff you should be safe to just nuke it
your mileage may vary
and double check your # rm -rf command
you don't want to do something smart like # rm -rf /usr/lib *
hello
beaky: Hi.
I read somewhere that it is possible to replace sum-types with closures. How is this done?
mSSM: okay, so the usr/local/bin/ was just full of ghc related stuff, so Ive cleared that out. Any further steps I need to take?
craigInnes: Check where else ghc files were put.
craigInnes: IF you are sure that it only put stuff into /usr/local/*, then you are fine.
craigInnes: check elliott's link.
craigInnes: Once you are sure of that, go install 7.4.*
note that my link is from 2007 and may be woefully out of date :)
mSSM: Do i have to change an environment variable or something so it doesnt point to the non existent version anymore or should the package manager be able to figure this out on itself?
mSSM: Nevermind
thanks for your help guys
ski: hmm, interesting, thanks
is "You could have invented monads" a good explanation monads?
+of
jason1: The only one, I think most agree.
If I have a data structure `data Foo = Foo { a :: Int, b :: MV.Vector Int }', where b is a mutable vector from Data.Vector.Mutable. If I now have a  `ob1 = Foo x1 y' and make a `ob2 = Foo x2 y', the y will be the same between the two, right?
You mean the second one will be a copy of the first? yes.
Wait, no, what.
Depends on your 'y'
srhb: If I now change the y in ob1, will it also be changed in ob2
?
mSSM: No.
I mean unless you got y from some other top level definition
jason1: do not try to "learn monads"
It's not quite clear to me what you're doing.
jason1: But do do the "You could have invented monads" exercises
jason1: it's the #1 mistake people make when learning haskell, one day they wake up and think "i want to learn monads"
mSSM: If you have y = makeSomeMutableVector -- somewhere, then yes.
But of course, then your syntax doesn't hold
neutrino_: why is that a mistake?
srhb: Yeah, I pretty much have that at the start... ok, here is a small explanation.
(other than that it's more a matter of *understanding* rather than *learning*)
tdammers: it's like learning hammers. you don't wake up one day and go "i'm gonna learn hammers today". you learn how to do things with them: drive nails, peen knives, assemble wood.
neutrino_: I think it's quite possible for people who are used to language-oriented metaprogramming to learn monads-in-FP
neutrino_: but isn't that the same with everything?
the thing is, you intuitively know what hammers are for because you've seen people use them all your life, you don't have that advantage with monads
srhb: I had a `data Foo = Foo Int [Int]'; I fill [Int] with random Ints at the start, and this list will stay fixed, but I update one element at every step. The first field in Foo Int [Int] is just the sum of [Int].
imagine a world where hammers don't exist yet
so you look at this abstract hammer and start coming up with bs to try to explain them to yourself
but we've been using let bindings or something similar a lot of our lives. Guess what do notation is?
srhb: To make my program faster, I wanted to replace [Int] with a mutable vector.
and end up trying to drive nails with the handle
mSSM: Yes, that much I get.
neutrino_: why would it be a mistake to learn something I have poor understanding of?
really, "don't try to understand monads" was a necessary discussion at the time but it's not the last word
or someone tells you "the wooden part is where you hold it, and then you can use it to beat against things with the metal part"
and you end up thinking monads are this: http://www.codinghorror.com/.a/6a0120a85dcdae970b017742d249d5970d-800wi
mSSM: so the question is: if I update one element in the mutable vector, and then sum over all the elements, how does haskell handle that?
oops
srhb: ^
srhb: since Foo has a pure and an impure part.
IMO, there's two things you need to understand about monads: how they're really not that special, and what you can do with them in practice
neutrino_: even though the label clearly says "PHP"?
the part that they're not really special is well ilustrated by learning about things that are monoids or applicative, and seeing how that contrasts with things that are monads
tdammers: that's the joke.
well
seeing how PHP is basically a huge monad...
so, again, we're back to learn-by-example
srhb: It would be very silly if it copied the entire mutable vector if I take a `Foo a b', `unsafeWrite b x', a' = sum b, and present `Foo a' b' as the result.
I guess what I'm getting at is that a bit of theory doesn't hurt
mSSM: Right. All that's wrong is your syntax.
neutrino_: they are 'special' in a sense, but so are applicatives, and so are monoids. What's special is that the set of capabilities the signature offers corresponds neatly to something notably more useful than we expect from programming abstractions
srhb: yeah, the syntax is terrible... but do you understand my question?
(what is an applicative functor? It's a language with function application)
Philippa_: but the same goes for a lot of other abstractions in haskell
you can look at examples of things that are monads / monoids / applicative / categories / etc and contrast. then, after a lot of examples, i think you can start reasoning on the "understanding monads" level
but that final step is not something a beginner to haskell or FP should be doing
hah! I had to "understand monads" before applicative functors were a published thing
mSSM: main = do { m <- makeYourMutableVector; let x = Foo 2 m; let y = Foo 4 m; return () }
since they need that big amount of context
mSSM: Something like that?
srhb: does that even make sense to create a data structure holding a mutable vector in addition to some pure variables holding information about that mutable vector?
eh. They need a moderate amount. Understanding the idea of a "simple let binding" and of an "embedded language"
mSSM: No, that's not possible
mSSM: That would be like saying that you can know the count of files on the file system without ever reading it.
now, language embedding is a big deal by programming newbie standards? But not necessarily to all Haskell newbies. Was old news to me when I was first deciphering the quicksort that Graham Hutton showed in the intro FP lecture
srhb: What I have is: `main = do { m <- makeMutableVector; let x = Foo 2 m; unsafeWrite 3 10 m; let y = Foo 4 m; return () }
srhb: But yeah, I suppose your example makes sense.
amusingly, language embedding is (slightly implicitly) a big deal in OO. A lot of people turn out to have the intuitions to match, too
srhb: Just that instead of let x and let y, I have an iteration which makes x' from x, and then uses x' to make x'', etc...
mSSM: But of course the Int in Foo still has no correspondence with the contents of m
srhb: ok, in this case. Let's say in between I have `n = mySum m', and then `let x = Foo n m'
mSSM: more like n <- mySum m
srhb: yes, of course.
mSSM: As long as you stay in the do block you're fine.
mSSM: You'll never be able to return a pure value from that from your function. But you may not need to. I don't know.
srhb: but does haskell now make a complete copy of m?
mSSM: No
srhb: good :D
Or, well..
Actually I'm in doubt
I assume it must, in fact.
Unless you use an IORef or something. Hm.
I think someone else needs to weigh in here, I don't know if mutable vectors are references in that sense. I would not assume so.
hi guys, I am trying to write a program which is able to compile text that a user enters as if it were a haskell source file and then runs a function within it. I am attempting to use the GHC API to do this but am running into a "cannot find module" error with my current function implementation. Can anyone help? http://pastebin.com/Sz7g1uY5
The paste Sz7g1uY5 has been copied to http://hpaste.org/80503
srhb: because at the moment I have `iterate (Foo n m) x | x == 0 = return Foo n m | otherwise do { updateMutableVector; n' <- mySum m; iterate (Foo n' m) (x-1)}
srhb: I think this one actually shows my problem.
mSSM: I'm scared to say something wrong now because of my lack of knowledge of mutable vectors. I think you should wait for someone else to respond.
srhb: ok, thank you :)
srhb: you know what - I think my question is silly.
mSSM: I have a feeling it is, but yeah... :P
how does pattern matching work
srhb: I am essentially trying to use the same algorithm just with a ompletely different representation of my data.
craigInnes: did you see hint?
@hackage hint
mSSM: You probably shoud alter your algorithm, yes.
srhb: It doesn't make sense to pass the mutable vector over and over
No.
One pass is enough obviously.
:D
what is the point of undefined?  just to test if something is being evaluated?
beaky: http://learnyouahaskell.com/syntax-in-functions
mercer: what do you mean?
craigInnes: in particular `eval' function: http://hackage.haskell.org/packages/archive/hint/0.3.3.5/doc/html/Language-Haskell-Interpreter.html#v:eval
does the implementation compile patterns into vtables/jump tables?
fmap: thanks for the link. From looking at the api for hint, am I to understand that this essentially does what I was asking for without having to directly use the ghc api at all?
is there a use of `undefined' besides checking if something is being evaluated?  eg. True || undefined
craigInnes: I'd guess so, haven't use it
mercer: Sometimes syntax demands a value, even though you can't provide one
mercer: while coding, undefined is a great place-holder, since it always matching the expected type
i.e. generating an array but not setting every value yet? undefined as default value (of course this means you need to be *sure* that it'll be updated before use)
And, yes, undefined is also a great placeholder for "code I haven't written yet"
merijn: every value for an array won't be set anyway, until you evaluate every member
craigInnes: you may also want to take a look at mueval, it provides safe sandbox around hint
@hackage mueval
mercer: I frequently start projects by writing function names and type signatures and just defining them as "undefined". Then I can do stuff like "map (foo . bar) baz" even though I haven't defined foo, bar or baz yet
mercer: And the type checker will guarantee the combinations I wrote are sensible, even if they have no implementation yet
merijn: I do that too
merijn what is the point of doing that if your code just crashes?
seeing whether it typechecks
mercer: because it type checks
and then you can provide the implementations iteratively
by writing tests, and then replacing 'undefined's until every test passes
mercer: You don't have to think about *how* you will implement things yet, you can start sketching a top-level view of your code, without worrying about *how* yet
mercer: Frequently you know *what* you want a function to, just not yet how to write that
mercer: And you can start writing other functions using functions you haven't implemented yet.
fmap: Thanks. When these libaries talk about "evaluating expressions" does this mean simply that they  can evaluate like a single function from a source listing in isolation, or does it mean they can evaluate it with respect to all the other imports, definitions etc. listed in that particular source file
mercer: Of course you need to implement them eventually, but this lets you postpone that while still letting you typecheck whether what you have so far is correct
I am asking because argument for Maybe over implicit null references is because Maybe forces you to deal with possibility of null (Nothing), while implicit null references don't, they can sneak in everywhere. but undefined can sneak in everywhere too, I'm not getting why null references are obviously bad but undefined isn't.
Bool", but you don't know yet what the Move and Board datatypes will look like. So you define "data Move; data Board; validateMove = undefined" and then you can write game logic, without having to know what you want Move/Board/validate to be yet
mercer: undefined *is* bad, it's just a neat tool for prototyping
so you would just use undefined to see if your code compiles, if types are matching
mercer: Yes
think of undefined as importing from the future ;)
ok that makes sense
If my "selectMove" function type checks using validateMove then I know it'll work, even though validateMove is currently absent.
also, if there are function results whose behavior really is "undefined", then you can return undefined
johnw: You should just use error in those cases
you can, or you can use undefined
error "Whoops, something broke!"
is it possible to have ghc do bounds check in compile time for the functions that index a constant list ?
for example, if I divide something by zero, is that an error, or is it undefined?
so you would use undefined in the place of throwing "Not yet implemented"  exception in other languages?
'error' is just a labeled undefined
mercer: undefined isn't like null reference, you can't say "if something == undefined then this else that"
jason1: precisely
mercer: Anyway, the point is not "null is bad, undefined is good" and more "null bad, undefined bad, but useful"
jason1: I would never do that. use error instead, if you must, so that you can say what happened
well, you can, but that won't do what you may expect it to do
yeah I got it
johnw: I don't understand under which circumstances what you are saying would be a good idea.
mercer: I think I've only seen 1 or 2 uses of undefined in actual finished code, for some obscure corner-case reason
srhb: what, using undefined instead of error?
johnw: Yes, like in your division by zero example. Of course error "Division by zero!" is better than undefined.
srhb: I'm often to lazy to type a message for error >.>
Either String b
merijn: That doesn't make it good practice :P
wuttf: map?
:t sequence
oh, no
srhb: No, look at the type
Yep, I saw. :P
srhb: Yes.
sometimes a function is generic enough that the error message isn't going to be descriptive enough to matter, but probably you are right
:t mapM
at least you can mention what function the error happened in
wuttf: ^
startling: =) Neat.
Either String b)
johnw: If you can say something about where or why, then surely it is better than undefined, always. If you can't, sure. I doubt that will ever happen.
mercer: See here another neat use of undefined ;)
oh, srhb reminded me
you can use undefined to pass type information
OMG you haskellers...
johnw: Right :)
sizeOf (undefined :: Int)
johnw: Though that's a completely different use.
yeah
Morale: Don't use undefined when you mean error. :P
that's something I just did recently, but in this case constructing a value is sometimes a chore, so undefined is the right option
wuttf: Embrace the laziness of not writing boilerplate when you can avoid it :)
Moral: Don't say morale when you mean moral.
How can I express "ignore everything from this point to the end of the line" in Parsec?
johnw: Thanks, language barrier.
covi: isn't there skipUntil?
merijn: I do I do.
covi: something along the lines of "many (not eol)" (not valid syntax (I think))
johnw: (exactly the opposite in mine :P)
covi: there's a combinator that does something like "many until" in the combinators module, IIRC?
startling: I didn't see skipUntil in the doc http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
wuttf: As a short explanation, "Either String" is the (an) error monad, i.e. monad for potentially failing computation. It behaves kinda like Maybe, but reporting an error String instead of Nothing
yeah, but you can skip by ignoring the result list
johnw: Proxy seems nicer than undefined for that.
merijn: `eol' is not defined
covi: That was supposed to be pseudo code :)
merijn: I know, thats why I chose it. I am rewriting a package which threw exceptions.
covi: newline
shachaf: for what?
wuttf: Oh, also. Similar to mapM, check out the monad-loops package
johnw: foo (undefined :: Type)
shachaf: how would you say that with Proxy?
and Proxy from which package?
startling: thanks
johnw: tagged
data Proxy a = Proxy
Hm, what's a good way to parse a Haskell module?  I will need to chase imports as well in order to get operator fixity right.
foo (Proxy :: Proxy Type)
Oh, neat
shachaf: that's better how?
That way you have no âŠ¥s in your program.
and you add a library dependency
No.
There is a parser in haskell-src-exts, and I could probably use the GHC API to chase library modules, but that will not be sufficient.
data Proxy a = Proxy is all it takes
ah
johnw: You don't even need the library dependency for consuming Proxy.
I didn't know that trick, it's so obvious once you see it. :P
... -- Note the lowercase p.
oh, tagged defines asProxyOf...
http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/GHC-TopHandler.html is a 404.  Why might that be?
b) as "proxy b" everywhere.
The actual type and functions are just convenience.
elliott: Oh, good point.
b) thing.)
shachaf: Proxy, without the lib dependency, doesn't work with siveOf
I get No instance for (Storable (Proxy Int))
so it's really not adding any convenience, simply to avoid having an undefined
johnw: Yes, sizeOf isn't defined to use Proxy.
It's defined to use undefined.
You can tell that from the type.
It's a bit unfortunate. All I'm saying is that Proxy is nicer.
where nicer means shachaf prefers it :)
startling: How can i implement the skipping part? "skip until newline"
covi: often one does manyTill anyChar (try (char '\n'))
or something similar
i'm surprised that parsec doesn't have skipUntil, like trifecta does
johnw: I think it's pretty common to try to have fewer âŠ¥s in your program if you can.
johnw: yeah, me too.
shachaf: I've used the id-as-Proxy thing before in actual code, I think.
covi: manyTill
shachaf: The problem is your type gets double the length.
elliott: Right.
Is there a better way to do it using only base?
shachaf: I type more undefineds, while playing "I like big butts" in the background
b?
johnw: thanks
a) as proxy a and then you just use absurd, but then you're depending on an edwardk package again.
shachaf: Ew.
I mean a better pick for "proxy".
covi: many (noneOf "\n")
mauke: oh, that's good
shachaf: I can't help but think we need more than one kind of equality constraint at times
johnw: OK, I'll stop telling you when I think there's a nicer option.
shachaf: i'm just teasing you
johnw: did you notice i picked up trifecta development again?
shachaf: i prefer hearing what you think are nicer options, over hearing just what you think are bad options :)
edwardk: cool!
edwardk: yes!  i pulled several commits this morning
everyone in #haskell-lens notices, too! at length
had to build lens from Git to build trifecta, though
edwardk: Does "development" mean "documentation"?
He added some lenses too!
Or is "It is a cofree comonad" still the only comment?
Philippa_ : hm, why ?
(I picked up two-level-constraints dev on the train earlier, not that I've pushed it yet - that, and mostly it was just adding a cofree comonad to go with the specialised free monad)
shachaf: hahaha
Philippa_: good timing with "cofree comonad" there
all the rage
elliott: heh. Well, I was going to add all but extend /anyway/
(plus it's renamed as Annotation, because I'm taking a domain-specific approach to naming all the functors flying everywhere)
shachaf: yes
shachaf: (yes, i'm adding docs)
johnw: yeah, i'm switching a lot of it over to using lenses
eventually i'll do the same with highlights in parsers
elliott: it's kinda weird, actually. Most of the lib is abstract syntax gadgetry so far
once they are a prism then we can have an open set of highlights
Philippa_ : i.e. why more than one kind of equality constraint ?
edwardk: is that just to make the code nicer, or will it change the API to?
ski: to internalise ways of talking about desired solving strategies
("this one just exists to desugar let bindings to", say :p)
so if you have one that just exists for let desugaring, you may as well just substitute on sight
these days, GHC has constraints that it chooses to defer
I figure the more we can talk about how we want things figured out, the more we might be able to get it to figure out the things we want without making a huge mess
Peter pasted â€œFastoâ€ at http://hpaste.org/80505
sqrt 9 :+ 4
sqrt (9 :+ 4)
what is up with this?
hey guys
why does sqrt apply only to 9 in the first example?
mercer: Function application always binds tighter than operators
i was thinking of starting to do tests for my code, but i'm not familiar with the different frameworks available for haskell
mercer: Similarly
i've heard of hunit, but not sure if that's the one i should start with
length [1..5] ++ [1..]
ok thanks
mercer: sqrt 9 :+ 4 === (sqrt 9) :+ 4
I thought 9 :+ 4 is a complex number literal
mercer: no, :+ is a regular infix data constructor, like (:)
:t (:+)
:t (9 :+)
fmap (+1) []
fmap (fmap (+10)) []
how come one works but not the other
:t fmap (fmap (+10)) []
Is there a way I ven reach fn1 from the outside: `fn = fn1 . fn2 where fn1 = foo; fn2 = bar;` ,
?
*can
jason1: Lists are only printable if their contents are printable, since that code doesn't know *which* functor you are using, it doesn't know whether that functor is printable
"reach"?
[Maybe a])
shachaf: call, invoke?
jason1: Saying the list is (for example) Maybe, which is a printable functor makes the result printable too
I don't think I know the proper terminus yet
jason1: Still following?
yes
I got a bit different error, about ambiguous type, but I guess it boils down to the same thing
Wizek: I was wondering not what the terminus was, but what you were trying to do.
Wizek: The answer is not really. fn is its own function, indepdendent of how you built it up.
jason1: Yeah, it probably referred to not knowing which Functor to pick
shachaf: so I have to define fn1 outside of fn, right?
Wizek: I have no idea what you have to do.
I think I got the answere I asked for, thanks shachaf
Why can't I catch exceptions outside of IO monad? Because we can't determine if the exception is thrown by a random hardware error or by program logic? That's the only reason I could think of
wuttf: because exceptions are side-effects
wuttf: Because they are observable side effects
wuttf: because you shouldn't be using them :P
wuttf: Suppose I have an expression throwing action foo, then running foo multiple times can produce different results (depending on whether an exception was thrown or not)
wuttf: i.e. don't use exceptions for reporting errors in pure processes
LadyAurora: Why not? Exceptions are perfectly sensible, just not for functions
length [error "boom", error "no really boom"]
^^^ because they aren't a reliable error-reporting mechanism
foo() { if(false) { error("boom"); } return 5; }
S11001001: that's more like "I don't understand Haskell's evaluation semantics" than "exceptions are not reliable error-reporting mechanism".
S11001001: whatâ€™s that supposed to prove?
merijn: because IO
merijn: if you're already in IO, then fine.
merijn: I don't get it, if the fact that an exception is thrown only depends on arguments, then for same arguments the result will be always the same (either exception or not).
bitonic: that sequence on Either e is a much better choice
Integers arenâ€™t a reliable number-summing mechanism:
wuttf: Not all exceptions depend on arguments
let a = 5 + 5 in "nope"
merijn: Then we should differentiat between them!
ion: integers aren't reliable at all:
let 5 = 6 in 5
wuttf: We do, we use Either/Maybe/etc for those that only rely on arguments :)
l!!0 `seq` l!!1 `seq` undefined)) 5 [1,2,3,4]
l!!1 `seq` l!!0 `seq` undefined)) 5 [1,2,3,4]
S11001001: that purely depends on how the user uses `error'.  `error' and `Either' are so different that they are hardly comparable
shachaf: What!
wuttf: If you want pure exception those data types work perfectly fine
:t upon
merijn: But it would be so handy. And, I am no guru, but if we could differentiate between exceptions caused by hardware (random, nondeterministic ones) and exceptions thrown by program logic, it would be possible to write code, which is referentially transparent, but throws and catches exceptions inside it.
o_o
srhb: Oh, you haven't seen upon? It's pretty great.
bitonic: the point is that types will tell you when you need to propagate Either e, they won't tell you to propagate exceptions
wuttf: How is that different from returning Maybe?
set (upon (fst . (!!1))) 0 [(1,2), (3,4), (5,6)]
S11001001: that is still vague.  if you understand `error', you understand your example
woah, funky.
let mylast [x] = x; mylast (_:xs) = mylast xs in set (upon mylast) 'x' "hello there"
bitonic: types check understanding
merijn: I am too lazy (and stupid) to juggle maybes and eithers.
S11001001: `error' is perfectly typesafe.  Haskell is typesafe
wuttf: Exceptions expose evaluation order and all sorts of things that shouldn't be exposed.
wuttf: You don't really have to, write all your code pure and then "fmap" it over the place that can return a Maybe
shachaf: How is that even possible. o_o
wuttf: Otherwise, use do notation + Maybe monad
srhb: It's not. You're dreaming.
wuttf: nondeterministic exceptions are thrown by program logic, not hardware
If I want to make a global IORef (evil cubed!), is something akin to "foo = unsafePerformIO $ newIORef 0; {-# NOINLINE foo #-}" a proper way to do it?
LadyAurora: Yeah
S11001001: note that I donâ€™t advocate using `error' instead of Either, I personally use `error' only for â€œimpossibilitiesâ€ and unimplemented stuff
bitonic: same here
srhb: It uses unsafePerformIO, if that makes you feel better.
srhb: don't worry, I have no idea how it works either
It'd go awry without the NOINLINE pragma, right?
Okay, I will stick to maybe then.
shachaf: It does, thanks :P
hahaha
byorgey: Phew!
srhb: Also, it uses exceptions. Which is why I brought it up in the middle of the exception discussion.
Sounds like a proper abomination :P
haha, that sounds so dirty
if it doesn't use brute force, I'm disappointed
@wiki Global variables
@wiki Top level mutable state
LadyAurora : see those ^
What it does is use Data.Data.Data to traverse the structure and replace every part of it with an exception tagged with an index.
Then it evaluates your function and checks which exception was thrown.
Then it traverses the structure again and sets that index to the new value.
I like proposal 2
shachaf: Yeah I actually guessed it was something like that once you said exceptions. You should see me now.
set (upon (!! 1)) 'X' "abcd"
stick a readerT monad in there and you're golden
shachaf: Data.Data.Data is the Haskell equivalent of badger badger badger?
(Actually it does something slightly more involved to make nesting work.)
x !! 1 + x !! 2)) 0 [1, 2, 3, 4]
shachaf: haha, awesome
mauke: Yep, it exposes evaluation order.
I wanted to extend it to set *all* the values that you force, rather than just one.
But on the other hand what's the point.
(It wouldn't be that hard, though.)
Oh, and there's a bug with nested upons.
:t sqrt 10
@ty sqrt 10
If you want to be a good citizen you should fix it!
why is this not Float
@ty sqrt
yes nvm
=D
nothing should be Float
@type sqrt 10 :: Complex Double
@index upon
Everyone said learn Haskell. It will be fun they said. Now I hate dynamic languages because they do no compile time type check. And hate static languages because they require dumb type annotations.
:t upon
meep.
I want my money back.
Ah
srhb: Data.Data.Lens
wuttf: Haskell is static and doesn't require dumb type annotations.
@ty onceUpon
i have found that in the glagolitic notation of old church slavonic, there are single-letter words for the quantifiers "exists" and "forall" and they look similar to the ones we use.
itoListOf (upon (!!4)) "hello there"
itoListOf (upon (tail.tail)) "hello there"
LadyAurora: That's why I want my money back. After this, I can't go back to either of those.
Hmm.
itoListOf (upon (tail.drop 2)) "hello there"
wuttf: Haskell is able to infer 99% of your type annotations automatically.
tac: except for the ones where you get fifty pages of type errors
such as when using lens
tac: see my last msg
:P
itoListOf (upon (snd.drop 2)) [(1,2),(3,4),(5,6),(7,8)]
neutrino_: I never felt any need for any lenses.
They seem like fad programming at its finest
have you spoken to your optometrist about this?
wuttf: no refund, since the complaint is invalid. You hate static languages because they require dumb type annotations, but Haskell it one of them and it doesn't require type annotations most of the time.
itoListOf (upon (snd.head.drop 2)) [(1,2),(3,4),(5,6),(7,8)]
itoListOf (upon (snd.head.tail.tail)) [(1,2),(3,4),(5,6),(7,8)]
Oh, right.
Anyway.
whats a nicer way for retarded?
LadyAurora *most static languages, but not Haskell of course. I am too stupid for haskell, but I need a static language with Hindley-Milner.
qasd: ??
wuttf: in this case, I'll gladly return you the $0 you paid me.
wuttf: prolog
wuttf: Try Ocaml/F#
neutrino_: it sounds kinda harsh, i want to tell a story with a retarded person involved but retarded sounds mean
wuttf: Same type system. Not as... Haskelly....
is there a word for retarded that isnt necessarily condescending
qasd: oh, you mean what a better word is
"handicapped"
qasd : perhaps "retarded" ?
qasd: so you thought "i need another word for 'retarded', where should i go... oh wait, #haskell of course!" ?
qasd: you seem to be in the wrong channel
OCaml has no threading support, F#, well I am thinking about that, but I hate Micro$oft. The F# tutorial begins with: "Download SilverLight". Oh, sure...
qasd: mentally challenged
wuttf: they fund your haskell fun
wuttf: You're painting yourself into a pretty narrow window.
qasd : maybe "slow" ?
neutrino_: Is Prolog actually a usable language?
I propose "dailywtf" as a substitute for "retarded", but I am not sure which one is more condescending :)
wuttf: F# works fine on Mono with the github.com/fsharp/fsharp install, join ##fsharp if interested
qasd: differently gifted :)
wuttf: access the F# Foundation website at http://fsharp.org
wuttf : i've talked to someone who uses it for Second Life
ocaml has a posix thread library
neutrino_: Well, they have the resources from selling a shit OS for money and spreading FUD abou competitors I guess.
wuttf: This isn't really the channel for that.
tac: Yes, I know that.
shachaf: Sorry.
rodrigovidal: Thank you for that link.
ah, special or challenged. much better words
what is going on
'sup dawg ? :D
HugeDaniel?
hi yoyo
YoYo_: sorry, i just saw this "hackagebot dawg 0.9 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.9 (JakubWaszczuk)"
and remembered the xzibit meme
that's cool
there's a meme?
Haha!
i put a meme in your meme so you can have a meme in your meme while you have a meme in your meme
Yo dawg, I heard you like currying, so I put a lambda in your lambda so you can apply while you apply... or something to that extent.
Hi
hi, i'm wondering how does the haskell lexer treat x<-1, since one can create an operator called <- in haskell, correct?
Spark: no.
<- is not allowed?
<- is for do-notation and list-comprehension
(and arrow syntax)
but you can create operators that end in a -
what about a>-1
let (^-) = (+) in 1^-3
1>-1
ok the lexer does what i'd exepct then
i think that answers it, thanks
Spark: maximal munch.
Hello, just to test irssi :D
LadyAurora: this would suprise people who are used to languages where if (x>-1) is allowed though right
leksah: you're a bad program, don't start irssi on your own.
this would be a greater issue for non-functional languages that are trying to steal programmers from java and c++
i wonder if scala has this problem
I don't think people who get turned away by 1>-2 are a coveted adoption group
(-b) in 0>-2
scala is the same as haskell
fwiw :)
hopefully programmers will accept that if you have a larger set of operators, you may need an extra space here and there
such as when space is itself an operator ;)
some really stoned computer 'engineering' student was telling me how scala and haskell were 'the same'
are you referring to Spark?
scala is the same as haskell (with respect to the elements of its design that are relevant to the discussion we 20 mins ago)
better? :)
please, this is #haskell, say "is the same as haskell up to isomorphism"
@help
hi! trying to learn some haskell here
can anyone help me out?
HaskellGuy76: you've come to the right place!
hi HaskellGuy76!
HaskellGuy76: Ask, and you shall receive.
byorgey: oh, hey!
I KNOW WHO YOU ARE HaskellGuy76
hi johnw!  were you looking for me the other day?
o_o
hi YoYo_!
hi Patrick!
hello! I am a high school student from texas and we are learning basic Haskell syntax and coding
due! I live in Texas too!
howdy from Texas!
That's cool. I'm up in Iceland over here
hey yall
what
excuse me but that is innappropriate
man who would choose such a rude name
seriously yonatan not cool
HaskellGuy76: you just reminded me, I need to call a co-worker in Texas!
well...
THANK GOD
you remembered!!!
Can you please change yur name
I am deeply offended
very cool! We have been learning the basics, like texas ranges and list comprehensions, wondering if you have any good resources
Texas ranges?
What on earth are they?
srhb: learnyouahaskell...
linduxed: Huh?
that's where you can define a list by not stating the whole list, [1..5] gives [1,2,3,4,5]
texas ranges is a playful reference to ranges
Ah, ranges.
[1,3..7] gives [1,3.5.7]
srhb: learnyouahaskell does all kinds of stuff like that
awesome
wow sounds like you know your stuff haskellguy76
man who was that other guy
that's so rude of someone to make their name like that
with that said, at no point does it say that they're *actually* called "texas ranges", HaskellGuy76
HaskellGuy76: they're just "ranges"
oops sorry for the mishap!
can i has a fstful of monads
HaskellGuy76: oh no worries
HaskellGuy76: that page does do some of those playful things from time to time, just keep an eye out for them :-)
It sort of reminded me of this: http://i.imgur.com/14cYJ.jpg -- I also imagined us being invaded by bald eagles.
help disjoin
have any of you guys read the book - "a haskell aproach to logical reasoning and maths"
how useful is Haskell actually? Can it be used like Java, or C? or is it used mostly as a side tool?
that book is tricky
YES
HaskellGuy76: It's a general purpose programming language.
That book doesn;t exist
It's the Haskell road to logic maths and programming
equalityforevery: hiptobecubic thinks it's pretty bad
okayyyyyy sorry
who is hiptobecubic?
I actually just started on the book, so I'd like if he could clarify on why it's bad :|
and yeah my class is using that for our Haskell independent study class it can definitely be a little much at times.
so I have a question about maps
YoYo_: Yes?
Tehnix, its very confusing for beginners
that's been my experience with it
equalityforevery, it's a logic book really
Not a haskell book
plus, if you're actually trying to learn how to implement haskell or its uses, this book is not the right one.
it makes almost no effort to teach haskell
equalityforevery: hmm, was more interested in if it taught some wrong things or such. The other thing, I'll get past
most people don't need to know how to implement haskell!
"Haskell is a member of the Lisp family" <-- I stopped reading right there :P
haha srhb
so is every language with an if statement? :p
hey guys
Philippa_: It's a very weird statement. :P
equalityforevery: Thanks a lot for naming such book. I was looking for such a topic in haskell
it's nice if you want to learn logic and proof writing and things
it's not nice if you want to learn haskell from scratch
yeah it more uses Haskell as a way of teaching complex math, proofs, and logic (i know, as the title describes) and in doing so it expects the reader to have a solid understanding of haskell previously as it doesn't explain it much, only uses it in demonstrations
yeah i agree with you hiptobecubic
do you know of a book great for starting haskell from scratch?
@where lyah
that^
it isn't fantastic but its the best i know of.
equalityforevery: does it cover monads though? (The road to logic book)
I think it does a pretty decent job. But it's missing practice questions
umm im only a little over halfway through it currently
Tehnix: You don't need a book to "cover" monads
oh, k
It does cover monada
monads*
Monads are a special type of functor :P
Monads are not even mentioned once in the logic book, I believe.
It was more to know if it got beyond just using somewhat basic haskell to prove things
hi everyone!
learnyouahaskell has a whole chapter on it though
pdf text search found 0 entries for 'monad'
sorry wrong book
hiptobecubic: My approach as well. :P
learn you a haskell has monads
what are monads?
Nobody really knows.
We all just pretend to know it.
Ah.
Monads are things that define >>= and return and obey certain laws.
fsvo. things.
The logic book is really not about haskell
That's why it's not called the "Math and logic road to haskell"
If anyone asks, just tell them monads are kinda like burritos but not exactly.
they are like burritos
They are so not like burritos.
:P
Just like that!
Maybe you just make shitty burritos :)
How DARE you.
okayyyyy
FIGHT FIGHT FIGHT
Can we please keep this PG
woahhhhhhhh
MY burritos can launch missiles
Anyway, I think we're letting ourselves be carried off-topic by the slacking Texas compsci class.
:P
hey thats not nice man
excuse you
I don't think that even disqualifies a movie from PG anymore
Very rude sir. We ust accomodate all types of people. Even the stupid ones
kids these days
dude not cool
have you seen my nickname????
EQUALITY
we didnt start the burrito conversation
seriiously.
Can someone please explain Monads
Absolutely not. It is impossible. Really.
YoYo_: they are like comonads without the co
what's up yall
Your only hope is to play with them and then have an epiphany
YoYo_: Look up "you could have invented monads"
i like to play with stuff
wow... 1029 users, impressive !
what is computer science?
We can give you some hints like "It's not hard." and "don't over think it"
I've got a function that takes two lists and returns a Bool list, and I can't figure out why I can't composite it with the and function
But you won't "get it" until you play
like: finalResult = and.myfun
Damian_: because and takes a list of bools, not a function
Damian_: That sounds right. What is the type of myfun?
@unpl and.myfun
bye!
does #haskell have most users on freenode?
WELL SCREW YOU TOO
[Bool]
What happened to pg?
Damian_: Looks right to me. I think you're doing something other than what you have said.
erkin, hiptobecubic: Saying "monads are like burritos" is completely unhelpful and tired inside jokes are even worse when you give them as answers to people who are actually asking questions.
and (f x y)
shachaf: They were not actually asking questions, don't worry.
shachaf, I did tell him the actual way to learn what they were.
using OpenGL, and having some weird problems not mentioned in the tutorials
importing Graphics.Rendering.OpenGL and Graphics.UI.Glut
jason1: nope. Your IRC client may well be able to give you a channel list, that'll show you what does
and they're having a lot of common functions
Saizan: Correct. Why doesn't the composited functions consume the second argument?
for instance, $= and "clear"
O.o
nobody mentions that
what's going on
and what do I use?
Damian_: because that's how it's defined
f (g x)
@src (.)
I used to have plenty of success doing exactly that with people in here back in the day
simpler times, eh?
ah, now I get it
Thanks
Philippa_: along which lines? embedded languages?
Philippa_: I think it helps the least common denominator somewhat... But maybe you are right.
Saizan: more or less, yeah
srhb: yeah. I mean, my explanations were /also/ long enough for it to be clear you'd still need a play to go from nominal understanding to grokking
i guess "you could have invented" tries to do that too
mmm. I should poke at my vaguely WIP tutorial again
(not actually entitled "Languages I Give A Shit About As Monads")
How can I get minimum of [Maybe Int] without using compare of Maybe's?
epta: is Nothing < Just ?
I hope so
No
Just < Nothing
Nothing < Just ()
I wan't to Just < Nothing
epta: then minimum . catMaybes
minimum . catMaybes
What about [Nothing]?
you'll get an error
treat it the same as []
I wanna Nothing
then you want maybe the minimum, no?
my question, anyone?
:t minimumBy
>:|
!list
cri9210: http://okmij.org/ftp
magneticduck: extremely vague
mauke: it's pretty much everything there is to it
I'm trying to make a simple application using OpenGl and GLUT
oh wait
I didn't paste everything
onc sec..
map (minimumOf (folded.folded)) [[], [Nothing], [Nothing,Just 10,Just 20]]
well
epta: foldr (min . Just) Nothing . catMaybes
i think that works
epta: ^
:t foldr (min . Just) Nothing . catmaybes
:t foldr (min . Just) Nothing . catmaybes
:t foldr (min . Just) Nothing . catMaybes
(foldr (min . Just) Nothing . catMaybes) [Just 3, Just 6, Nothing]
:t minimum . filter (/= Nothing)
hello!
For [Just 1, Just 3, Nothing] I want Just 1, for [Nothing] I want Nothing
MagneticDuck pasted â€œOpenGL hello world problemâ€ at http://hpaste.org/80510
kk
all hail hpaste
any answers NOW?
msum [Just 1, Just 3, Nothing]
:D
msum [Nothing]
epta: You saw what I pasted?
epta: msum
msum [Just 3, Just 1, Nothing]
oh
msum ok, thanks
-.-'
Just $! (min x y))) Nothing . catMaybes $ [Just 4, Just 1, Nothing]
epta, msum is not the minimum
Ow :[
Just $! (min x y))) Nothing . catMaybes $ [Nothing]
let xs' = catMaybes xs in minimum xs' <$ guard (not (null xs'))) [Just 4, Just 1, Nothing]
let xs' = catMaybes xs in minimum xs' <$ guard (not (null xs'))) [Just 4, Just 1, Nothing] :: Maybe Int
let xs' = catMaybes xs in minimum xs' <$ guard (not (null xs'))) [Nothing] :: Maybe Int
<$ ?
anyone?
:/
@src <$
Thanks
:t (<$)
guard . not . null `fmap` catMaybes
magneticduck: you could try and see
catMaybes
lol
Just $! (min x y))) Nothing . catMaybes
Just $! (min x y))) Nothing . catMaybes
let xs' = catMaybes xs in minimum xs' <$ guard (not (null xs')))
map (minimumOf (folded.folded)) [[], [Nothing], [Nothing,Just 10,Just 20]] -- still the simplest solution :-p
ah that's interesting
haha, fix . const
i've never seen @pl say that
:t fix . const
:t catMaybes
Lethalman: fix . const = id
catMaybes [Nothing, Nothing, Just 10]
parcs, oh
glguy: Hmm, it looks like that can lead to a stack overflow.
:t liftM2 (<$) minimum (guard . not . null) . catMaybes
Maybe we should define minimumOf/maximumOf with fold{l,r}{,'}?
You know, "one of those".
is left associative
:t minimumOf
map (minimumOf (folded.folded)) [[], [Nothing], [Nothing,Just 10,Just 20]] -- still the simplest solution :-p <--- for what problem?
epta: yours
Oh, map is here just for get all variants
Got it
am I missing something? is minimum . catMaybes  no good?
jason1: minimum . catMaybes $ [Nothing]
minimumOf (traverse._just) [Nothing]
minimumOf (traverse._just) [Nothing, Just 6]
Lens to the rescue
minimumOf (traverse._just) [Nothing, Just 6, Just 10]
:t traverse
Taneb: You're late to the party :-p
glguy: what should it be instead, Nothing?
:t _just
\o/
jason1: Right, the specification for the function was to return a Nothing if no minimum was found
Lethalman: correct
p (Maybe a) (f (Maybe b))  now
Lethalman: 'traverse' is a pretty normal function. It'll be a good one to understand
glguy, what did I miss
here p = (->) so its not as terrifying
edwardk: It's OK, your types are complicated ;)
heh
glguy, yes not scared by that one in fact :S
Taneb: That solution :)
:P
glguy, if more than one person came up with it independently, that means it's good!
works for me
is there a better way to apply some function n times?
let f g n = (!! n) . (iterate g) in f (+1) 10 0
I like it
appEndo . foldMap Endo . replicate n) 10 succ 0
appEndo . foldMap Endo . replicate n)
pl is niave sometimes
And I can't spell sometimes
Try "fold(r/l) (.) id"
Taneb: forgot an a
Taneb: I wanted to see what pl would output ;)
:)
print "Hello everybody"
did you mean: putStr
:D yes
it's a kind of magi
c
Hey everyone, I'm teaching a 12-week introductory class on Haskell: http://shuklan.com/haskell
and I'm giving my first lecture at the University of Virginia this Tuesday
Please check it out!
nice!
binroot: if you have any particularly talented students who want to intern or work for free on free software, let me know
binroot: sweet!
A bug in GHC seems to keep me from installing the text package.. where can I post a message on that so someone can help me?
whoah 40% for attendance :p
LambdaDusk: hpaste.org
Clint: I'll keep you in mind
parcs: I thought that was only for haskell pastes
Also you guys are invited to enroll in this haskell class
LambdaDusk: it's a general purpose purpose pastebin but it's primarily for haskell pastes
Clint: What are you working on?
any thoughts on Haskell for number-crunching tasks?
parcs: Yes but the ghc devs are not really looking there for bug reports , right?
oh, I thought you wanted help
clahey: a bunch of different things; timekeeping, contact management, enhancements to hledger, enhancements to gitit, etc.
Solution to earlier problem:
I don't know what foo means (?).
maximumBy (comparing $ fmap Down)
maximumBy (comparing $ fmap Down) [Nothing]
:(
maximumBy (flip compare) [Nothing]
Not quite the same
maximumBy (flip compare) [Nothing, Just 7]
With my thing, I think that's be Just 7
LambdaDusk: http://hackage.haskell.org/trac/ghc/report
alanz: Thanks
Thank you cesc !
I'll fix it right away
binroot: just a wild question. I am a fortran guy; most of my computational needs are reading in arrays or matrices from files, manipulating them, and writing them back out. , will there be an example on loading numerical data from a file, manipulating them, and writing them back out? I spent quite some time learning Haskell, but I was never confident enough to do these things...
C, C++, java and the other OO bollocks are out of the question for me at the moment. Haskell seemed worth a shot :)
cesc: Ofcourse! There will be an entire lecture on IO
Lecture 8 really focuses on that, just before diving into monads
will we have to wait until Mar 5? :))))
cesc: C is not OO...
companion_cube: jupp, sorry didn't proofread. I actually started with C but ended up doing more debugging than number crunching, so Fortran it was! =)
binroot: Which lectures?
cesc: haha, if you want the secret early version, http://shuklan.com/haskell/lec08.html
shapr: http://shuklan.com/haskell/index.html
spiffy!
binroot: you, sir, are awesome! Thank you very much!!!
shapr: We're talking about a class I'm teaching this semester, http://shuklan.com/haskell You guys should enroll :)
binroot: do you take Catalan physicists currently in Germany as exchange students? xD
cesc: I'm warning you, those slides are currently just a draft. I'll perfect them when the time comes
I'm taking five classes at una.edu, but a Haskell class doesn't sound too bad.
binroot: Does it cost money?
shapr: no money
ok, I'm interested.
binroot: thx. it's celestial literature already as it is
All slides are online, its a free open class
Actually the website is even opensourced https://github.com/BinRoot/Haskell-Lectures
whoa awesome!
binroot++
*rejoicing*
I'm a third year CS major at una.edu, this course should be fun!
Hell yea!
Admittedly, I do have some prior experience with Haskell outside of school.
Oh good choices for reference texts :-)
shapr, how goes the raspberry pi quest?
shapr: Those are my favorite 2 books
Taneb, rpi is yesterday's news
Taneb: I'm looking for a place that has a 512MB Pi in stock at the moment, and trying to figure out how best to pay for it with cash in pocket and paypal on internet together.
Sculptor: but I'm making new news!
shapr, save your money
Sculptor: why so?
I will assume this sudden quietness means there are no reasons someone should not buy a Raspberry Pi!
binroot: I'll advertise your online course, maybe you'll get more registrants!
Thanks shapr
I really appreciate it
shapr, save your money for this http://www.hardkernel.com/renewal_2011/products/prdt_info.php
binroot: That "qsort" function is a completely different algorithm from the C code.
It's hardly a fair comparison.
I will assume this sudden quietness means there are no reasons someone should not buy a Raspberry Pi! - no i was looking for the url
Sculptor: Nah, that's significantly more expensive than the Raspberry Pi. $35 is cheap enough to kill through experimentation and replace where $89 is a bit too much for a college student.
shachaf: Yea I agree. How should I phrase it instead?
shachaf: It's 'similar'
fine
Sculptor: Also, I'm learning lots about how Haskell handles in less than 1GB of RAM
Sculptor: Another advantage of the Pi is that there's a huge community behind it.
i yet have to see a decent rpi project
While I agree that the ODROID-U2 is a more powerful platform, it's not as popular.
Sculptor: I've seen lots, and I'm making one myself :-)
k
In my opinion the Raspberry Pi is the Arduino of the Linux world.
binroot: I would say it's just misleading. :-)
binroot: If you wanted, you could write a simpler algorithm in C too.
shapr: In a good way?
i hate tarduino
Sculptor: Ah, I'm a fan of the Arduino. What do you think are other good options for the Arduino price/functionality?
Rembane: Yah, I'm a fan of both the Arduino and the Raspberry Pi
shachaf: Sure. I'll figure out a better example.
You don't need to compare Haskell to C to say that it's good. The languages have mostly different purposes.
shapr: Sweet! :)
shapr, good options are everywhere
Rembane: It's a bit hard to build with GHC on my 256MB Pi, but I've just gotten funding for a 512MB Pi to see if that makes things easier.
Sculptor: Got any specific suggestions?
say, this $15 board http://www.st.com/internet/evalboard/product/252419.jsp
shapr: you can't cross-compile?
johnw: Does ghc do cross-compiling?
well, what I normally do is setup your target environment in a VM
shapr: That sounds really nice. :)
build your final executables there, copy them over
that way you don't have to install GHC on a tiny platform
I've had some problems with that: https://bugs.launchpad.net/qemu/+bug/1042388
try VirtualBox?
Rembane: It's great, if you get a Pi I have experience using Haskell on it.
Not so much experience using the Arduino from Haskell, but it has been done.
shapr: I got it in a box somewhere...
shapr: http://www.raspberrypi.org/phpBB3/viewtopic.php?f=9&t=2961
Sculptor: I put in a bunch of hours trying to use the msp430 and Renesas RX chips from Linux, but it's a monstrous pain in the butt. The Arduino IDE is beautifully smooth and consistent.
binroot: That lecture site is incredibly sleek, wow!
shapr: I really hate the arduino IDE.
Sculptor: One of my requirements is that my entire toolchain be open source.
startling: Really? How would you improve it?
to each their own. supper time
shapr: the stm32f4 can be used with gcc for arm, I do it all the time
anybody used a 3d library here?
I was looking for something like libclutter
shapr: Well, I'd love for there to be an officially-supported command-line toolchain.
there are bindings but they are a bit old and probably not much functiona
what library should I look at for handling graphs?
osfameron: which kind of graphs?
I hung out with David Mellis once in Boston.. he said "You're doing good stuff with #haskell, what do you think would increase the popularity of the Arduino?" I said "The Arduino is already popular."
for writing a very simple game with simple 3d graphics
peddie: Ok, I'm interested.
startling: general graphs, e.g. directional, possibly cyclic
osfameron: oh, so you don't mean the data visualization kind. :)
srhb: Thanks! The source is here https://github.com/BinRoot/Haskell-Lectures so you can learn from it if you want
Sculptor: I would like to hear more about which microcontroller boards you like, when you get back from dinner, talk to me on #haskell-blah ?
startling, that would be chart
startling: heh, no -- I clarified that for someone else earlier, sorry, should've been more specific :D
shapr: HaLVM might be a good (or better) starting point as well -- I'm not too picky. I just want to be able to run Haskell on the Raspberry Pi bare-metal
i think Data.Graph looks like a fair start
Lethalman: people use "graph" for both
binroot: Neat!
stepkut: I'm interested. What might be the easiest path?
shapr: no idea :)
stepkut: Are there any options other than hOp and HaLVM?
shapr: I tried to install hOp the other day.. but it requires GHC 6.2.. and due to autoconf bitrot, etc, it does not build out of the box... someone updated hOp to GHC 6.8, but the link is dead. I emailed them but have not heard back. I am not sure how HaLVM works.. but it actually sounds closer to what I want and was built around a more modern GHC.. so it seems worth checking out
I only know of hOp and HaLVM
stepkut: lighthouse from kenneth graunke
lemme get you the git repo
stepkut: http://wiki.cs.pdx.edu/gitweb?p=lighthouse.git;a=summary
ah nice
stepkut: I asked Rebekah Leslie-Hurd about the L4 kernel work pdx did, but there's no consistent copyright or license assignment.. I should email Mark Jones...
that is probably based on GHC 6.8, so it would take some effort to update. unfortunately, we can't just use GHC 6.8, because we need ARM support ;)
right
oh yeah.. there was some Haskell l4 thing..
Yah, that's the one.
right
stepkut: wasn't there some Linux distro that used Haskell for system stuff? ;-)
:)
there was also a paper on using Haskell to write linux kernel modules :p
of the things.. HaLVM is the only option currently maintained AFAIK
I think so.
which is a good argument
I agree
and.. it's stated purpose is to allow for bare-metal apps, which is what I want as well
an OS can be nice.. but for embedded projects, bare-metal seems more better
and HaLVM designed for/on virtualization, so it would be good for hosting down the line
I guess the first step is to email the HaLVM people and see what they think about the difficulty of ARM/RPi support
I'd assume so.
That is, when the 64-bit ARM chips show up in datacenters doing virtualization you'll have a smooth upgrade path.
does anyone have any familiarity with the haskell hint libarary? I am trying to figure out whether you can load a module created from a user created string. I see from the hint examples that you can load modules from saved files, and that you can evaluate string expressions...
stepkut: I agree
Craig: Yes, you can, want lots and lots of example source?
shapr: are you going to write them, or should I?
Craig: dig through the prototypes directory here: https://github.com/shapr/ghclive
stepkut: classes just started today and I'm organizing a tech meeting this weekend, and trying to get my funded Pi for more Haskell hacking
shapr: Cool thanks. I was struggling to find examples. The hint page has only a single example file
stepkut: So if you have time, that would be nice :-)
Craig: I used hint LOTS for my google summer of code project this past summer, I can likely help with hint.
Craig: What are you trying to do?
shapr: Cool. Basically what i am aiming for is a really crude part of and IDE. i.e someone can type a bunch of haskell code into a text box in gtk, and have the program evaluate and run it
Craig: You should try to install ghclive :-P
Craig: http://i.imgur.com/w5e5D.png
shapr: ah, there is a mailing list, I will check the list first, and then send a post, http://community.galois.com/pipermail/halvm-devel/
stepkut: yay!
shapr: However, most of the examples i have seen deal only with using the eval function to evaluated an isolated function, rather than a function within the larger context of a piece of source
Is there a better place than the Haskell Wiki to go for a beginners intro to xmonad setup? I think I'm about to take the dive...
while cond action
the $ symbol is really ugly :(
Oh?
maybe you can do (â‚¬) = ($) ?
lol
beaky: You'll get used to it.
shapr: sent!
stepkut: w00t!
shapr: also, links to your KS projects?
I didn't create KS projects :-P but I did get 512MB Pi funding from Taneb and opticron and crashcartpro
m i (+ 1)
stepkut: I may create a KS project for an ARM build machine for ghc/debs, but I don't know which hardware is the best choice yet
The ODROID-U2 that Sculptor suggested may be the best choice if it'll run Raspbian and produce armhf binaries. 2GB of RAM for $90 is hard to beat.
shapr: nice. Would be cool to run the autobuilder on it.. but we would have to fix the RAM usage first
Does the autobuilder use lots of RAM?
shapr: yes.. far more than it should
shapr: it's definitely a bug.. but we usually run it on machines where it doesn't matter :)
It would certainly matter on any ARM systems I've seen.
how would you define the data for a rubik cube?
shapr: yup. would also help on my laptop
Lethalman: could you define a zipper for a rubik's cube?
as a list of faces? but that wouldn't be fixed
shapr, why whould I need that?
*would
shapr: just never had enough motivation to investigate
shapr, I'm not going to have a search space
Why is pBench' faster than pBench? https://gist.github.com/4496832
shapr: but the autobuilder would be a great tool for building deb packages.. it can automatically pull packages from hackage, debianize, and build them
stepkut: that sounds perfect for what I want
hi
shapr, I don't know if to use data Cube = Cube [Face] or = Cube { face1 :: Face, face2 :: Face, ... }
i have a somehow logic related question
does anyone know why the universal quantifier can be encoded as All(P) == (P = (\lambda x. True)) where P is a predicate?
shapr: yup.. we use it to build 300+ packages at work on a regular basis
shapr: and it is written in Haskell :)
shapr: the only major issue I can think of offhand is the RAM thing, which is totally fixable
stepkut: Building on the Pi is slow and sometimes requires more memory than it has, so I hope to produce binary debs for most anything on Hackage that can be installed on Raspbian
True means you get True for any input.
I'm getting an error trying to install pandoc: https://pastee.org/wvvy4
shapr: exactly!
anyone seen this and/or know how to fix it?
I'd rather not break packages....
shapr: I can think of no better tool than the autobuilder for that
also sorry, new to haskell
shapr, yeah, so why would All(P) be true iff P is a function returning true for all inputs? how is that universal quantification?
kate_r: âˆ€x.P(x) means that P is true for any argument you give it (in its domain)
It is universal quantification over all inputs.
True)
kate_r: You know about Howard-Curry right?
b
right right
jdahm: I usually just do --reinstall and hope nothing breaks, I don't know if there's a better thing to do.
yeah
shapr: in theory, you just add a list of all the hackage targets you want to build to the config file, and then it automatically debianizes and builds them. If you run it again later, it will only rebuild packages that have changed on hackage, or which have updated dependencies.
^^ that's not right... right?
it should be f a = f a
Lethalman: Looks OK to me.
f a = f a is a recursive definition.
Lethalman: I think you're thinking of: f a b = a b
shapr: because the config file is actually a Haskell source file (like xmonad) you can even create the list of build targets programmitically
stepkut: Right, and they'd all be available on my VPS or wherever I decided to host the apt source.
That's hopefully not what you want.
Q?
I'm thinking of ($)
:t ($)
@src ($)
right
($) = id
simpson, ok
kate_r: Makes sense.
thanks
look at it this way:
kate_r: For example consider Q = Void
b)
shapr: yup
shapr: the autobuilder supports uploading to a remote host, and then you use newdist (part of the autobuilder suite) to add the packages to a local apt-get repo
hmm
hey ladies
let me write some haskell
True, right?
but how is that the existential
kate_r: Try Q = False, not True
shachaf, then ALL x. P x has to be false?
kate_r: You know how âˆƒx.P(x) = Â¬âˆ€x.Â¬P(x)?
at least classically.
in pBench I tried to implement the "sieve of Eratosthenes", and in paper that would seem to be a more efficient than how pBench' is written. Or does Haskell's compiler optimize the latter in some way?
gich: command not found
shapr: alternatively I could remove ~/.ghc and ~/.cabal and start over?
Nereid: Right.
stepkut: I know someone who purchased an ODROID-U2, I'll see if Raspbian runs on that.
jdahm: Yes, I do that myself sometimes.
shapr: never got big into using haskell problems until now
jdahm: As far as I can tell, the problem you are experiencing is understood, but the solution is not :-)
shapr: hardkernel only supports android 4x and ubuntu 12.10 (their own custom build, I believe)
m b)?
i have an odroid-u2 coming hopefully in a week
thoughtpolice: That maybe sooner than my friend can try Raspbian on his, I'd love to know if it'll boot an drun!
Since #ubuntu is less than helpful, does anyone know how I make my .xsession show up in the lightDM greeter?
quchen: No.
quchen: You should use the join/fmap/return definition of monads to see how that works.
The monoid associativity law is join . join = join . fmap join.
shachaf, yeah, i've seen that before, but don't quite understand how.
m a is mappend in some sense?
kate_r: Well, take some concrete predicate to get some intuition for it. :-)
that law just says
there are two ways to go from m (m (m a)) to m a
and they are equal
quchen: It's easier if you think about composition of "m"s, i.e. ignoring "a"
You have (m . m . m) a
You can collapse that in two ways: (m * (m * m)) and ((m * m) * m)
Ah, I see.
is Â¬âˆ€x.Â¬P(x) parsed as (Â¬âˆ€x).(Â¬P(x))?
kate_r: that's not syntactically valid.
thoughtpolice: Think you'll have time to try to boot Raspbian?
Â¬(âˆ€x.(Â¬(P(x))))
shachaf: how does mempty fit?
kate_r: No. Â¬(âˆ€x. (Â¬(P(x))))
mempty ~ return
right
i meant, in shachaf's ignoring-a scenario
shachaf: So can a monad in Haskell actually be written as a monoid, or is that something not easily expressible?
m
âˆ… should be the "identity m"
for endofunctors, the monoidal identity is the identity functor.
so return is a natural transformation from identity to m
ok, but we're not talking about the Identity functor
m a
no.
that's not the identity functor.
rather, the identity for m
no, I do mean the identity functor.
the one that takes a to a
shapr: i doubt raspbian will work; the hard-float FPU in the RPi is significantly different than the one in the ODROID (the microarchitectures are significantly different.) ARM doesn't have what you would call 'unified booting' in a sense, so you typically need an image made for the board
(not a to Identity a)
ah, i see
so without a significant amount of work, i doubt it
but i will probably be able to get ubuntu on it without too much difficulty i imagine
So, the ODROID-U2 wouldn't make a good build machine for Raspbian debs then :-(
so, identity functor * m = m, and m * identity functor = m
sure.
saml pasted â€œmaybe fold shortcut?â€ at http://hpaste.org/80512
I think that's a type error?
shapr: it could! but you'd need to adjust the compiler to emit the correct ARM code, and cross compile
Well, depending on what you mean by "identity functor"
identity a = a
a
the honest identity.
shapr: i think this is how people build the packages now anyway; they just build a copy of GHC for ARM on some more powerful board, and make sure it's properly compiled to run on e.g the rpi
badri
hi
shapr: really GHC just needs to become a cross compiler, and it's getting very close i think
thoughtpolice: The Raspbian guys build debs with the Freescale i.MX53 quickstart board with 1GB of RAM
Hi badri, are you learning Haskell?
shapr: why not build it in VirtualBox?
wha's shortcut of this?  http://hpaste.org/80514
yeah
shapr: yeah, so you'd need a bit of fiddling to make it work properly, but it's definitely doable
there are a, b, c, d, .....  list of Maybe
shapr: you just won't be able to boot the raspbian kernel on an odroid, is all
johnw: I don't have any reason other than that I haven't tried that yet I'll look at that thread you linked when I have a larger chunk of spare time. The virtualbox image they list is old
johnw: it's an ARM machine
heard abt it in a technical seminar, wanted to try it
thanks guys, i got it now
thoughtpolice: ah
HsColour makes ghci bad! any good option to colour ghci' life?
badri: You could try it with http://tryhaskell.org/
badri: Do you have any particular questions about Haskell?
x { getA = a })
er
shapr: i'm thinking of turning my small set of ARM machines into a build farm for GHC
thoughtpolice: that would be awesome :-)
well that would do it.
(i have 3 powerful enough to build GHC)
saml: (<|>) might be useful
yes, I am using the interactive tutorial
and <*>
well, i will have 3, once the odroid gets here :)
Just (getA x)
no that's not it.
thanks let's see if i can port this to scala
got some links - http://www.haskell.org/haskellwiki/Tutorials
is it really good for parallel processing?
wait.. but i want to modify existing rec instead of creating a brand new one
code that would work effectively in HPC?
http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:(<|>)  ?
badri: What flavor of HPC?
doesn't do what you want.
well I guess it can be made to.
kind of.
badri: There's support for array unrolling if you have a bunch of graphics cards in a system.
badri: http://www.haskell.org/haskellwiki/Parallel
ibm
badri: You mean distributed computing across multiple blades in a bladecenter?
thx
m ()
badri: I've heard this will do some of that: http://www.haskell.org/haskellwiki/Cloud_Haskell but I'm not sure how much.
:(
oh there is such a thing.
great thanks. really helpful links
how can I make  x { getA = a }  part into a function?
you write a function.
setA x a = x {getA = a}
meh
let me get my hands dirty first. thanks
records are sad :(
alternatively, use lens
:D
i have initial data or record.   I'm parsing user input.. user might only specify some of the fields of the data.. and i want to update the data.
lenses are beautifully ridiculous
:t maybe id (?setA ?x) ?a
since i'm parsing, missing user input fields will be Nothing
errr
:t maybe id (flip ?setA) ?a
there's no shorcut to lay user input fields over existing data?
why does importing a nonexistent module in ghci not cause ghci to display an error?
kini: it does.
kini, because it's an error
maybe i need to make monad
RecordUpdateMonad
you can do it with the state monad, sure. lens would be extra helpful here
:t whenJust
@let whenJust Nothing f = return (); whenJust (Just a) f = f a
Hey
:t whenJust ?a (?l .=)
wait.
im new in haskell, i have program to write, something operations with matrix
Nereid: that argument order seems odd
Nereid: a `whenJust` f?
is haskell new decision?
is there a cool guide to install hp with ghc 7.6?
zl64c, there are libraries for doing linear algebra. the most famous being hmatrix
johnw: by analogy to when
What on earth does "new decision" mean?
can i specify constant functions (in the context of classes/instances)? i.e. something like instance Class Type where myFunction = 3 ?
:t when
it's not meant to be used infix.
that doesn't discards embedding on the result
Dexteri: you can, but you need to use a little trick
s/doesn't//
it's actually Data.Traversable.forM_, if that existed.
wouldn't that be in Foldable?
what trick?
Dexter|: if we have data Tagged a b = a, then we can have class Foo a where someConstant :: Tagged Int a
?index forM_
ah it is.
well, it's Data.Foldable, anyway
:t Data.Foldable.forM_ ?a (?l .=)
handy
Dexter|: now the function in our type class refers to the class introduced in the type class (which is essential)
and you can just use for_, you don't need to say forM_
fine.
ocharles i'm not sure i understand what you did there
Dexter|: and to use it, we do someConstant :: Tagged Int Foo, or someConstant :: Tagged Int Bar
:t for_ a f
doesn't make much difference.
it's makes so MMMMMMMMMuch difference
Dexter|: The trick is the 'Tagged' data type, which has a phantom type to mention which type the constant is for
I'd rather use forM_
because then that doesn't add an Applicative constraint on the monad.
:t Data.Foldable.for_ ?a (?l .=)
:t assign
well, for_ needs Applicative and Foldable, and forM_ needs Monad.  pick your poison I guess
but I'm giving it a monad.
fair enough
in any case
ocharles the type of the constant is clear (see http://ideone.com/kY4tnW, line 9) - but i'm not sure about the syntax or even whether somethin like this is possible
use lens, it makes your code pretty.
forM_ ?b (assign _2))
bleh.
forM_ (Just 3) (assign _2)) (0,0)
i sure hope this is not the prettiness of which you speak :)
what's not pretty about it?
hi there
heyo
Nereid annotated â€œmaybe fold shortcut?â€ with â€œmaybe fold shortcut? (annotation)â€ at http://hpaste.org/80514#a80515
lens
what's not pretty about this.
saml: ^
Nereid, thanks
it's certainly doable without State too.
haskell's new forth. every library is own DSL
I don't konw why Data.Traversable doesn't have mapM_ and forM_ and so on.
If State makes your code pretty then use STATE
Sun Tzu said that
Nereid, they're in Data.Foldable
Every Traversable is a Foldable
D.T has mapM and forM etc
so does Foldable
er
no.
ok
"Every one sees what you appear to be, few really know what you are, and those few dare not oppose themselves to the opinion of the many, who have the majesty of the State to defend them." - NiccolÃ² Machiavelli
hey
You could neaten it further by saying "for_ a $ assign recA" rather than "mapM_ (assign recA) a"
:t assign
I had it like that before, but I like it this way better.
(.=) = assign
ah, I was just wondering
[[a]]
recA .= a?
not quite.
[[a]]
or are you using mapM_ because a is a Maybe?
why?
a is a Maybe.
yes
I want the pred version! :(
ah, gotcha
a :)
skp, splitWhen
[[a]]
unhelpful :(
Taneb: huh?
skp, use splitWhen
the haskel.org website is not up to date then?
Presumably
so, whenJust = forM_. I guess I'm ok with this.
Nereid, or for_ if you've just got an Applicative
sure.
Taneb: thank you very much
:)
:t forM_ `asTypeOf` whenJust
No problem
:t Data.Foldable.forM_ `asTypeOf` whenJust
:t whenJust
I defined it earlier.
Yeah, you only need an Applicative
of course.
why does >>simplify (Add (Minus a) a) = (Value (zeroElem a))<< fail with >>Repeated variable "a" in pattern?<< (code on http://ideone.com/4sm7XU)
because you have a repeated variable in your pattern
and you can't do that.
Dexter|, because pattern matching doesn't work like that
Use a guard
oh, ok
simplifiy (Add (Minus a) b) | a == b = ...
why does zeroElem take an argument?
because i don't know how to do it argument-free
and the Group Double instance doesn't work.
zeroElem :: a
why doesn't it?
because 0.0 is not a function, and you said zeroElem is a function.
:t 0 . 0
I'd make Group a subclass of Monoid
oh, ok, yes, that part of the code doesn't macht the definition
*match
g
anyway, you can just write zeroElem :: a
or what Taneb did.
that is valid?
class, not instance.
Group (Sum a) where invert (Sum a) = Sum (negate a)
Group (Product a) where invert (Product a) = Product (recip a)
no need for the Eq, Show, Read constraints on Group either.
http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Unboxed.html#v:accum copies the vector only once, is this correct?
and I'd probably get rid of isZero.
but that's just me.
Taneb: invert 0
Nereid, recip 0
read/show i need for the io part of the code, and == is used in simplify
Some types may play nice
fine.
recip (recip 0) :: Double
:P
lucky accident.
oh
instance Group () where invert = id
Dexter|: but you're only using that for Expr, not an arbitrary Group.
also get rid of that Group constraint on Expr.
it does absolutely no good ever.
hm?
expr is the class
it's not a class, it's a data type.
Expr a
er
...
I guess.
what's wrong with expr?
well I don't underestand what simplify is supposed to do.
symbolic simplification - stuff like a+0 = a, a+(-a) = 0, etc.
Group (Endo' c a) where invert (Endo' f) = Endo' (inv f)
Don't know if Endo' is defined anywhere
Either (p b x) (p b y)"
those operations look weird.
They have to do with opposite lenses.
Everything is weird in opposite lens world. :-(
they must, because the arrows go the opposite way to what I know.
:(
Isn't the former "I promise we only use one of x and y"
Nereid: The arrows are opposite but the variance of the arguments is also opposite.
And the latter "I promise we only result in one of x and y"
@ty (***)
@ty (|||)
These are the "opposite" of those arrow operations.
(÷÷÷)
Both of those arrow operations accept products, so both of my operations return sums.
(By products I actually mean two arguments.)
Wait, no, I'm lying.
That's why that didn't make any sense.
The operations that these are opposite to are
p a (b,c)
p (Either a b) c
dysinger: did you get any help with static builds?
@ty (&&&)
(p a b, p a c)
shachaf: what kind of p has such operations?
(p a b, p a c)
*, hth
:(
you know what I meant.
Forget r
r
Oh, uh, and (->)
Wait, no.
I'm listing off things that have diffract
Just, uh, the opposite of these?
Proxy?
Remember?
(<-)?
Goodnight, guys
Nereid: The main one is Bizarre
p b a
:(
?
why does this approach with guards result in an "infinite" type? http://ideone.com/1Hxt6A
Nereid: I have more weird operations for you if you want them.
no thanks
p b a ?
nope
Nereid: What's the opposite of a category?
Surely you know things like that.
a category
hmm.
no wait.
well,
the opposite category of a category is a category.
but I bet there's a dual notion to "category"
The question is: What constraints on p do you need to make (Bizzare p a b) a Category instance?
what do you know http://ncatlab.org/nlab/show/cocategory
Either (p x z) (p z y)
Which is to say, uhh, one of its sides is coercible?
that's cocomposition.
OK, what should coidentity be?
or is it.
p x y?
Void
??
fuck
Why Void?
I can't gift it back to banana because he already has it
Uh oh.
oops wrong channel.
because.
Void is dual to ()
Are you sure it wouldn't be p x y?
Hmm.
sorry, I asked already a time ago, but nobody answered -  http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Unboxed.html#v:accum copies the vector only once, is this correct?
I guess void gives you p x y...
npl: based on it being O(m+n) and not O(mn), I'd say so.
Nereid: ah, that makes sense.. thanks =)
Nereid: Any idea what the oppositism for representable profunctors would be?
what are you trying to do.
Nereid: We came up with this Bizarre thing to let us turn around any profunctor lens.
And get the full power from the inverse lens.
why
Because that way you have from which can turn an iso around, and also turn a prism around?
And every other lens structure.
this is getting too weird.
It's great!
Nereid: What's a Cocategory like?
Do they make any sense in Haskell?
oh wait.
I haven't thought enough about what a cocategory is.
http://ncatlab.org/nlab/show/internal+category take the definition, turn around all arrows, and replace the pullback with a pushout. I guess.
Either (p b a) (p b' a')
*That's* op-***
:(
http://shuklan.com/haskell/ not sure if anyone saw this
except
hmm
because a Category isn't a category internal to Hask.
because the objects of a Category do not form a type
they're * instead
hmm
ok I don't know what a cocategory would look like in haskell.
guys, I'm trying to go haskell 7.6.1, and got to the point of cabal's Setup.hs. I have the env set correctly, but Setup.hs reports unmet dependencies on base whereas ghc-pkg list base correctly outputs base-4.6.0.0. clues? where does the default package-db of ghc-pkg sit?
it's separate for each version of ghc
so...
Nereid: I know, where does it sit?
uh
I have global in /usr/lib/ghc-x.x.x and user in ~/.ghc
or something
æ—©ä¸Šå¥½
QinGW: Early up like!
when porting code from Persistent 1.0 to Persistent 1.1 i'm getting "Couldn't match type `PersistMonadBackend IO' with `Database.Persist.GenericSql.Raw.SqlBackend'". the weird thing is that SqlBackend is an uninhabited type. any clues that might help me understand this and fix it?
good morning
I want to multiply all elements in one list with all elements in another list, how do i do that? I can't figure it out myself
why hackage are used to so low version number? it means it's far from stable?
zipWith (*) [2,3,4] [2,3,4]
Like that, ThrIce?
Also an option, if you don't like that:
[ x*y | (x,y) <- zip [2,3,4] [5,6,7] ]
[ x*y | (x,y) <- zip [2,3,4] [5,6,7] ]
thank you, i started to get crazy ;)
haha I was just reading that tinking "thats totally not valid Ruby code, what the hell"
then, derp, wrong channel =)
[x*y |  x <- [2,3,4], x <-[5,6,7]]
hah
[x*y |  x <- [2,3,4], z <-[5,6,7]]
[x*y |  x <- [2,3,4], y <-[5,6,7]]
Awesome.
okay,there
print "pining ThrIce"
lol
that was a fail
@type print
@type show
Yes, one is the Cartesian product, the other is the vector product.
ThrIce, your question could have been interpreted in two ways.
well, i was trying to calculate [2,3,7] * [1..x]
what is [1,2] * [3,4] supposed to be?
Pseudonym is suggesting that more than one thing might count as
is it
so to get {2 * 1, 2 * 2, â€¦, 3 * 1, 3 * 2, â€¦}
*
zipWith (*) [1,2] [3,4]
liftA2 (*) [1,2] [3,4]
its supposed to be pseudo code
but what does it mean
well, calculate 2 * 1, 2 * 2, 2 * 3, â€¦. and then 3
3 * 1, 3 * 2 and so on
liftA2 (*), then
liftA2 (*) [2,3,7] [a,b,c,d]
Or the list comprehension that applicative said.
or that.
People should use list comprehensions more.
they're probably easier to have intuition about.
getZipList (liftA2 (*)(ZipList [1,2])(ZipList [3,4]))
liftA2 (*) [2,3,7] [a,b,c,d]
var "Hello, world!"
excellent
text "Hello world"
:t text
oh ok
var "Hello, world!" * 2
this is cool
but yeah, why not use a list comprehension.
@type var
Can i ping myself using that bot?
var "ThrIce"
yeah
map var $ words "here are some words"
lol
so I have Constructor a b c d e f g, and I wanted to provide these parameters automatically from a list
tried with fold but no luck
it's right telling me it needs an infinite type
it thinks the list is the first argument
f [a,b,c,d,e,f,g] = Constructor a b c d e f g
(but then what happens when the given list has the wrong length? etc.)
[1..]
â€¦ disappointed :D
fix$(0:).scanl(+)1
x) [1,2,3,4]
^^
you can't do that.
eh :)
ok
makes sense
maybe you could do something with polymorphic recursion, I wonder.
or some typeclass trickery.
where does Setup.hs look for dependencies in the first place? isn't it supposed to be reported by ghc-pkg? are there any incompatibility issues with Cabal-1.14 with ghc-7.6.1?
Nereid, you mean with (->) ?
?
Normal must be the most boring lens type in the world.
Lethalman: is this the same question as http://www.haskell.org/pipermail/haskell-cafe/2012-December/105478.html ?
shapr: alas, my message to the Halvm-devel list bounced for some mysterious reason.. hopefully the postmaster email goes somewhere useful..
sure, http://www.haskell.org/pipermail/haskell-cafe/2012-December/105492.html
and also maybe a fundep would help with that.
peddie, yes, I can't read the solution, is there?
Lethalman: it's in the message that Nereid linked -- just follow the "next" link from the original message
ah ok
good to know it's somehow possible :)
maybe all that it's not worth it for 6 arguments eheh
what about a list where the difference between 2 elements is always 1 greater that the difference between the previous two values? something like [1,2,4,7,11,16â€¦] How would i go about doing that?
wait what about oleg http://www.haskell.org/pipermail/haskell-cafe/2012-December/105482.html
sure
more type safe.
wait.
ThrIce, your list doesn't seem to be valid then, 4,7,11 ... 11 is not greater
never mind.
sorry the difference not the sum
scanl (+) 0 [1..]
scanl (+) 1 [1 ..]
that's awesome
\o/
scanl1 (+) [1..]
BTW, ThrIce...
0 : 1 : f xs (tail xs))
iterate (scanl1 (+) [0..5])
let go n inc = n : go (n + inc) (inc + 1) in go 1 1
That might be a little easier to understand how it works.
iterate (scanl1 (+)) [0..5]
let go n inc = n : go (n + inc) (inc + 1) in go 1 1  -- try again
is there a genericReplicateM somewhere?
iterate (scanl (+) 0) (take 6 $ repeat 1)
ThrIce : do you understand that one ?
aw.
iterate (scanl1 (+)) (take 6 $ repeat 1)
zipWith (+) (head x) x)
transpose . take 6 $ iterate (scanl1 (+)) (repeat 1)
zipWith (+) ([0] ++ ns) (ns ++ [0])) [1]
oops I accidentally made pascal's triangle.
@let pascal = iterate (scanl1 (+)) (repeat 1)
fix $ (0:) . scanl (+) 1
fix $ (0:) . scanl (+) 1
pascal 6 3
er
pascal !! 6 !! 3
Nereid : Pascal's quadrant ?
:t fix
close enough.
pascal !! a !! b = (a+b) choose b.
yes
ski Yes, thats really great
@let choose c b = pascal !! (c-b) !! b
6 `choose` 4
@let pascal' x y | x >= 0 && y >= 0 = pascal !! x !! y | otherwise = 0
@let choose' a b = pascal' (a-b) b
map (choose 6) [0..]
map (choose 6) [0..]
oh I did something wrong.
map (choose' 6) [0..]
I discovered a curious phenomenon once upon a time regarding Pascal's Triangle
I discovered one too. Yours first.
lemme think
Nereid : is it defined when `x + y < 0' ?
sure, as 0
 map (flip choose' 6) [0..]
Nereid : but then `choose (-1,0) + choose (0,-1) = choose (0,0)' doesn't hold :/
oh wait, maybe it isn't.
er, `choose (-1,-1) + choose (-1,0) = choose (0,0)' rather
or maybe it is.
or maybe it isn't.
(confusing the quadrant formulation with the triangle one)
all my trace is being interleaved with all my other trace
wat do
let c n 0 = 1; c n k = c (n-1) (k-1) * n `div` k in map (`c` 6) [0..]
it's whatever it has to be to make the binomial formula work
I'm using traceIO
theorem
@define f m n = map ((`mod` n) . flip choose' m ) [m..]
yeah, that's it
and then unsafePerformIO
f 10 20
f 10 20
some kind of lock maybe?
well,  anyway,  the size of the image of every (f m) is a multiplicative function of n
Pseudonym, that's mine
choose n (-1) has no sensible definition.
Interesting.
Pseudonym, oh wait,  I think I told you that one before
@let lpsmith m n = map ((`mod` n) . flip choose' m ) [m..]
Let me try and recreate mine.
int-e: yes it does, choose n (-1) = 0.
just describing it to you guys makes me think it's just plain concurrency
for natural n.
choose (-1) n = (-1)^n
or
yeah, if n >= 0
and 0 if n < 0
it has to be, to make the binomial theorem work for (1 + x)^-1
@let lpsmith m n = map ((`mod` n) . flip choose' m ) [m..]
lpsmith 10 20
Nereid : though it breaks the symmetry :/
not really
you want choose a b to be a polynomial in a, for fixed b
[ sum [ choose (n-k) k | k <- [0..n `div` 2] ] | n <- [0..] ]
[ sum [ choose' (n-k) k | k <- [0..n `div` 2] ] | n <- [0..] ]
That's the one.
Exercise: Prove this.
Yeah, I discovered that it was already known about a few years after I discovered it at age 16 or so.
is hPutStrLn atomic?
putStrLn isn't
Nereid: I agree about choose (-1) k for k >= 0. That wasn't the point. It's k<0 that doesn't make sense.
mreh: no
for k < 0, choose n k = 0.
always.
for integer n
Nereid, mauke, k
it should be for small strings when appending to a file if it had unix semantics
(+1) . do { x <- ask; return (x*2) } $ 5
ski:  and since [ flip choose i | i <- [0..] ] is a basis for the Integer Valued Polynomials,  you can use that to demonstrate that the image of all integer valued polynomials (mod n) is a multiplicative function of n
binroot: Isn't there a difference between the codomain and the range?
niteria, I'm just going to use a global MVar abstracted away in a module
binroot: How do I post questions about the lectures?
@ let choose1 a b | b < 0 = 0 | otherwise = product (map (a+1-) [1..b]) `div` product [1..b]
@let choose1 a b | b < 0 = 0 | otherwise = product (map (a+1-) [1..b]) `div` product [1..b]
lpsmith : "Integer Valued Polynomials" being defined how ?
ski, any polynomial that maps integers to integers
You can prove that they must have rational coefficients
map (choose1 4) [-1..5]
map (choose1 (-1)) [-1..5]
ok, so not only integral coefficients
right
interesting
also
it's a very nice basis for such polynomials
forward difference is easily expressed in it, for instance
hmm, even with a semaphor and withMVar my function is still interleaving output from several threads
map (choose1 n) [0..n]) [0..]
"forward difference" ?
diff f n = f (n+1) - f n
or maybe backward difference is nicer, I forget.
and it's useful in practice.
e.g. the (forward? backward? I forget) difference of the hilbert polynomial of an algebraic variety is the hilbert polynomial of its intersection with a generic hyperplane.
you mean 'discreete derivative'?
yeah, it's the discrete version of the derivative.
using that, you can easily find a polynomial that fits the data point
data points*
well, if your data points have x = 0, 1, ..., n
then yes.
and find it represented in newton basis
x
x `div` y
it generalizes to other x's
well you'd have to use a different basis.
choose x 3
choose1 x 3
Example
hey guys i hope you can help me i want to do this x*y without using * , im trying to use only + - so how can i do it ?
blue592: ??
smells like homework
are x,y integers?
yes
repeated addition?
there's a clue
nop ^^
yes
that is a clue
for example 4 * 5 = 20 but im trying to do this 4 + 4 + 4 + 4 + 4 = 20
so compute 4 * n recursively.
but i cant use this operator *
we know.
blue592: assume you have to multiply by 0
it's easy for the naturals
I just did it
blue592: what is the result?
so a recursion is the clue
sorry, not helping
0
ok, so f x 0 = 0
jep
for f x y, assume y is not 0
0.
so you trying to compute x*y where y>0
can you write that differently?
what do you mean with differently
someone gave you x * (y - 1), compute x * y
blue592: ok, assume y is 1
ok
result is x
assume y is 2
x+x
and so one
on
so, when looking at subsequent values of y, you get: 0, x, x+x, x+x+x, x+x+x+x, ...
right?
right
let's get #haskell to do some golf for me. if I have an infinite list of infinite lists [[a00, a01, ...], [a10, a11, ...], ...]
so, given a list of such values, how do you calculate the next one?
I want to turn that into [[a00],[a01,a10],[a02,a11,a20],...]
ok maybe not quite golf, just something pretty :p
[_:xs] maybe
blue592: just in words - not haskell code yet
same trick as in Q ~ N?
Nereid: code synchronized swimming :P
niteria: yeah, diagonalization
heh http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/src/Control-Monad-Omega.html#diagonal
diagonalization is different
or so I thought
stripe is what I want, I think.
no, I'm right
you use it to prove R !~ N
you're right to think what you want?
can anyone recommend a good sqlite package for a novice haskeller?
yes, stripe does what I want. ok
monkey operator :D
niteria: hmm, how can you use that to show that R is larger than N?
(i know it is, just don't see how to use that in proof)
map ((,) n) xs
not that, it's just that the classic argument is called diagonal method
yes, for showing N^2 ~ N
you make a list and take a diagonal, flipped diagonal is not in the list
hmm
but I don't want to concat.
that's it.
if I've already defined an Ord instance for a type, why does the compiler complain that I haven't defined Eq (and is there a trick to prevent that?) ?
because Ord has Eq as a superclass.
the trick is to define an Eq instance.
you can cheat: x == y = compare x y == EQ
or maybe it's easier to define == directly.
alright
this also looks like a job for template-haskell :)
you can derive Eq
and Ord
hmm, now I want a similarly pretty way of inverting a formal power series.
I got it.
:p
If I want to define Iso without lens dependency I need to wait for 3.8, right?
Right.
oh, probably wrong channel
oh well
Well, you can do it now, you just won't be able to use it. :-)
You still need a profunctors dependency.
Then it'll just be iso sa bt = dimap sa (fmap bt)
(If we had profunctor lenses, it would be iso = dimap)
nice, I can live with profunctors
but can profunctors live with you? :O
cmccann: Profunctors can't live with me. :-(
cmccann: I'm wondering if "p a b" means something like "exactly one of {a,b} is inhabited".
they probably got tired of all the puns.
do you guys do any work with sql databases?
hey, anyone know which of virthualenv and hsenv is currently being worked on?
i'm giving up on cabal-dev
shachaf: in what context? your thing with the mpose operation and all?
Yes.
isn't that how I described the dual of implication?
"a AND not b"
That says that a is inhabited and b isn't, right?
oh, right
I'm saying that exactly one is inhabited, but you don't know which one.
misread, sorry.
And mpose tells you which one by coercing the other one.
And coid takes an absurd value, i.e. (a,Not a), and gives you anything.
that seems to make sense
b
ah, ski might have some idea about this as well
Well, it's not actually (a,Not a)
It's p a a
stuff that mysteriously migrated here from #haskell-lens
It happened around the time that cmccann mysteriously migrated here from dinner.
that part isn't mysterious.
it involved me eating my dinner.
is #haskell-lens any fun ?
Lots!
Either (p t x) (p x s)
Where ? is either Void or p x y
hm, perhaps your `?' and `Either' could be some tensor structure on a category
(which your cocategory is internal to, obviously)
p a x"
ski: I mentioned that it seemed to resemble dual-intuitionistic logic
s/tensor structure/monoidal functor/
I.e. contravariant in the first argument, covariant in the second.
Like (->)
which ? `p' ?
p, yes.
if you take "p" as being the pseudodiference or whatever
which I think we were talking about the other day
shachaf : a profunctor sounds similar to a difunctor then -- is there any difference ?
What's a difunctor?
http://hackage.haskell.org/packages/archive/compdata/0.5.2/doc/html/Data-Comp-Param-Difunctor.html ?
exponential is a difunctor
Looks like the same thing.
Apparently it has a bunch of other names, like "distributor" and "bimodule"
cmccann : "it" being ?
ski: the specific "p" that would allow the coid and mpose operations shachaf mentioned
or a specific such profunctor at any rate
ok
probably more than one that would work
I don't think this has much to do with profunctors.
Just like categories don't.
There's no mapping over a and b.
C) is valid
but it's been a little while since I was considering this stuff
Does , on the right side of |- mean disjunction?
yes.
shachaf : typically a multiplicative disjunction
in dual-intuitionistic logic it ends up conflating both linear logic disjunctions
in exactly the dual of how (,) conflates both conjunctions in Haskell
likewise you have an additive-only conjunction dual to Either
and pseudo-difference gives you a way of encoding multiplicative conjunction
  âˆ€ x,y,z : â„. x < z â†¦ x < y âˆ¨ y < z
so you can have a dual of the CPS encoding and recover classical logic from the other direction
Hm.
ski: That's interesting.
A)) I think
or something goofy like that
y' or `âˆ€ x,y : â„. x â‰¤ y âˆ¨ x â‰¥ y'
This looks very related.
Similarly x < x â†¦ Void
Or in this case it might be x < x â†¦ âˆ€ y,z. y < z
Aha, http://www.fnds.cs.ru.nl/ccorn/documentation/doc008.html
"irreflexivity".
I guess antisymmetry would be the opposite of abelian categories?
Not (y < x)
Or maybe not.
calls it "comparision"
Hrm.
shachaf : that's asymmetry, not antisymmetry
speaking of nlab, there's also this: http://ncatlab.org/nlab/show/paraconsistent+logic#dual_intuitionistic_logic_10
I always thought you invented that name.
what name?
Dual intuitionistic logic.
ah. no.
if it was me I'd probably just put a "co-" on it.
less typing.
it's kind of obscure though, not many people seem interested in it.
Cointuitionistic logic, to coin a tutionistic logic.
i
if it was up to me there would also be more puns based on "counter-intuitive"
shachaf : "Dual-Intuitionistic Logic" by Igor Urbas in 1996 at <http://projecteuclid.org/DPubS?service=UI&version=1.0&verb=Display&handle=euclid.ndjfl/1039886520>
Fruitionistic logic uses banana brackets heavily in its notation.
is there a logic monad with unification implemented?
a'la prolag
prolog*
1/(1-2*t) :: FormalPowerSeries Rational'
1 + 2 t + 4 t^2 + 8 t^3 + 16 t^4 + 32 t^5 + 64 t^6 + 128 t^7 + 256 t^8 + 512 t^9 + 1024 t^10 +...
hooray.
who knows why I was doing this.
(Rational' is Rational with a different Show instance)
(and FormalPowerSeries a is a newtype for [a])
danr : i implemented one once
Nereid: nice :)
(1+t)^3
1 + 3 t + 3 t^2 + t^3
yeah.
Nereid: how
@type (>>-)
t is [0,1]
@type ifte
(1+t)^3 is [1,3,3,1]
(wrapped in a newtype)
though iirc, `MonadLogic' doesn't support a logic variable interface
Nereid: do t / (1 - t - t^2)
i was just learning about generating functions today
t / (1 - t - t^2) :: FormalPowerSeries Rational'
t + t^2 + 2 t^3 + 3 t^4 + 5 t^5 + 8 t^6 + 13 t^7 + 21 t^8 + 34 t^9 + 55 t^10 + 8...
Nereid: did you read that paper on formal power series in haskell?
nope
Nereid pasted â€œformal power seriesâ€ at http://hpaste.org/80517
stripe is ripped from Control.Monad.Omega
exercise: figure out why inv' works.
Nereid: http://www.cs.dartmouth.edu/~doug/pearl.ps.gz
Nereid: how are you computing the coefficients of each term
well, it's from the observation that
(1 + tf)^-1 = 1 - tf + (tf)^2 - ...
which is where powers . map negate comes from
and the rest is some ugly thing to make it work out.
right but t / (1 - t - t^2) is not of that form
1 - t - t^2 = 1 + t (-1 - t)
so we can compute the reciprocal of that.
:O
hi
ski: do you have the implementation on hackage?
in logic, what is a 'preferred model'?
what's the generating function of f(n) = f(n-1) + n
(x^2+x)`div`2) [1..10]
scanl1 (+) [1..10]
Is that what you mean?
sure, but what's the generating function.
no.
oh :)
the power series whose coefficients are 0, 1, 3, 6, ...
it's a rational function.
I just saw what parcs wrote. I haven't seen all that stuff above. Carry on :)
t/(1-t)^3
t + 3 t^2 + 6 t^3 + 10 t^4 + 15 t^5 + 21 t^6 + 28 t^7 + 36 t^8 + 45 t^9 + 55 t^1...
parcs: ^
What is that, the Taylor series?
it's a formal power series.
sin t
Oh.
I didn't see you pasted that yourself.
Now you have to supply the result, Hafydd.
@goog generatingfunctionology
it's actually the taylor series too no?
Well, if you insist.
sure. but formal power series don't have to converge anywhere.
@google generatingfunctionology
@googoogachoo, I am the walrus
t - 1/6 t^3 + 1/120 t^4 - ...
ICBF to compute the rest.
And that's t^5
bwahahahaha
fix ((1+) . integrate)
1 + t + 1/2 t^2 + 1/6 t^3 + 1/24 t^4 + 1/120 t^5 + 1/720 t^6 + 1/5040 t^7 + 1/40...
fix (integrate . (1-) . integrate)
t + -1/6 t^3 + 1/120 t^5 + -1/5040 t^7 + 1/362880 t^9 + -1/39916800 t^11 + 1/622...
Hafydd: :)
what's that
sin t
and exp t before it
oh right
nice
Heh.
Nice.
sum $ scanl div (10^100) [1..100]
is \top true in all models?
lol
any germans here to help me ^^
In my model, top spins
x + sin x) $ 3
wow
I'd be more impressed if you didn't use sin.
After all, you can just find its first positive root.'
hmm, now I want to represent fractional powers of t.
or negative
pro620: with haskell?
Puiseux series, apparently they're called.
oh
that's basically x = x + sin x
it's also using Newton's method to approximate a zero of sin near 3.
or wait.
no, not quite. one could do that, though.
b?
x - sin x / cos x)) 3
x - sin x / cos x) 3
uh
how can add up an value ntimes if i want to use this a function like this func x y
x - sin x / cos x) $ 3
that's newton's method.
what method is the original?
uh
for example func 5 4 = 5 + 5 + 5 + 5
= 20
x - log x - exp 1) $ 3
iterate (5+) 0 !! 4
x - log x - exp 1) $ 3
iterate (5+) 0 !! 4
iterate (5+) 0 !! 4
:(
x - log x - exp 1) $ 3
oh
x + log x - exp 1) $ 3
x + sin x works.
x = x + sin x = (x + sin x) + sin (x + sin x) = (x + sin x + sin (x + sin x)) + sin (x + sin x + sin (x + sin x))
well it's newton's method for finding a zero of log (csc x + cot x), I suppose.
or is it.
x + log (asin x + atan x)) $ 3
no, just csc x + cot x
repeat (0/0)
Hahahah.
x + asin x + atan x) $ 3
:(
x - f x / f' x) x0
newton sin cos 3
did I just
shit.
@undefine
x - f x / f' x) $ x0
newton sin cos 3
http://www.wolframalpha.com/input/?i=y%2Fy%27+%3D+cos+x
it's the root of that thing
(pi + epsilon) + sin (pi + epsilon) = pi + epsilon + sin pi cos epsilon + cos pi sin epsilon = pi + epsilon - sin epsilon
2*x) 1
That's the reason why it works.
x + sin x
Pseudonym: nice
pro620: func = (*)
which works, because the absolute value of its derivative is less than 1 near 3.
so it converges.
@let fixpoint f x0 = (!!100) . iterate f $ x0
x + exp (2*atanh(tan(x/2))) $ 3
x + exp (2*atanh(tan(x/2)) $ 3
exercise: prove it converges.
shachaf: probably wishful thinking, but do you know if http://hackage.haskell.org/trac/ghc/ticket/7436 is going into 7.6.2?
pro620: or maybe you want other things than Int for the first argument
i.e. if |f'(x)| < 1 for x0 - e < x < x0 + e, then iterating f will converge when starting in the interval (x0 - e, x0 + e).
liyang: Not sure. I've wondered myself.
maybe that needs to be a closed interval.
no it should be fine.
liyang: I see an origin/ghc-7.6 branch which doesn't have the patches.
Although they're in HEAD.
let func x n = sum $ take n $ repeat x  in func 5 4
let func x n = sum $ take n $ repeat x  in func (5.0) 4
liyang: Why is the non-eta-reduced example O(n^2)?
I would have thought that both examples given are the same except for notation
x + sin x) $ pi
x + sin x) $ 0.0
x + sin x) $ 0.000000000000000000001
haha.
quchen: the comments explain itâ€¦
x + sin x) $ 10^(-100)
x + sin x) $ pi/2
x + sin x) $ 10^^(-100)
x + sin x) $ 10^^(-300)
er
x + sin x) $ 10^^(-30)
uh oh
yeah. 0 is an unstable fixed point of x + sin x
x + sin x) $ (pi/2 - 0.01)
x + sin x) $ 10^^(-30)
x + sin x) $ (pi/2 + 0.01)
x + sin x) $ -1
it has fixed points at multiples of pi. the even multiples are unstable, while the odd multiples are stable
that explains what we are seeing.
x + sin x) $ 9
3*pi
x + sin x) $ 2*pi
heh.
x + sin x) $ 6.283185307179586
x + sin x) $ 6.28318530717958
x + sin x) $ 6.28318530717959
there you have it.
x + cos x) $ 0
sqrt (2 + 2*x) / 2) $ 0
:s
I like that one.
fixpoint (2/) 2
er
x + 2/x) 1
hmm.
x/2 + 1/x) 1
(x + 5/x)/2) 1
Pseudonym: how does that work?
sqrt (2 + 2*x) / 2) $ 0
sqrt (2 + 2*x) / 2) $ 0
sqrt (2 + 2*x) / 2) $ 0
well the point is that it's an infinite product that converges to 2/pi.
oh i didn't see the (/2)
Yes.
sqrt (2 + 2*x) / 2) $ -0.1
:t fixpoint
:t (!!100) . scanl (.) id
er
:t (!!100) . iterate
noo.
:t (!!100) .: iterate
ohhh
fixpoint (+1) 0
liyang: I asked in #ghc, for all the good that does.
riiiight
:p
shachaf: I've asked on the ticket. :)
liyang: Oh, even better.
2 / sqrt (sqrt 2)
oops
i need more paper
Pseudonym: i will solve your riddle
Which riddle?
sqrt (2 + 2*x) / 2) $ 0
sqrt (2 + 2*x) / 2) $ 0
I didn't intend that as a riddle, but okay.
i will solve it anyway
apparently that infinite product is due to ViÃ¨te.
http://en.wikipedia.org/wiki/Vi%C3%A8te%27s_formula
parcs: ^
x*sqrt(2 + 2x) - sqrt(2)) $ 0
x*sqrt(2 + 2*x) - sqrt(2)) $ 0
Nereid: thanks
@hoogle NaN
Hello?
Hello, recursive fun!
fix ("Hello " ++)
kfish: when do you get in to Canberra?
text (cycle "Hello ")
great.
fix (text "Hello" <>)
var (cycle "Hello ")
@type var
@varrr
var x^2
shachaf: heh
oh.
SimpleReflect.var x^2
urgrhhh
var "x" ^ 2
:t SimpleReflect.var
oh duh.
Nereid: So type inequality is one example of an uncategory.
haha
Either (p x a) (p b y)
ivanm, change of plans, not coming sorry ... was just in sydney for xmas but back in singapore now
oh; was the heat too much for you? :p
:ho fix
@hoogle fix
fix (1 +)
fix (0:)
fix (1 +)
uhoh
if n == 0 then 0 else n * f (n-1)) 5
er
if n == 0 then 1 else n * f (n-1)) 5
Interesting. ghci on my computer is locked up doing "fix (1 +)". But I don't see any CPU activity.
Isn't that identifiable as a black hole?
let omega = 1 + omega in omega
what, exactly, is ghci doing with "fix (1 +)" if it isn't using any CPU?
OK, maybe not.
roadfish: It might be stalling.
fix (1+)
*** Exception: <<loop>>
It's been a while since I looked at this part of the GHC internals, but it might be assuming that another thread is doing the recursive computation, so it waiting for that.
no cpu usage, no allocations.
So what you've actually got is a deadlock.
Pseudonym: someone explained it a few months ago
it takes about 5 seconds to output that message though.
Right.
when you evaluate a thunk, it's changed to a blackhole that does one of two things
2^n * sin (pi / n)) 100
on the unthreaded runtime, it errors because you have clearly looped into the exact same thunk over again
I've been running "fix (1+)" for much longer than 5 seconds. I think it will sit there forever.
2**n * sin (pi / n)) 100
on the threaded runtime, it waits for the "other thread" to finish
2**n * sin (pi / n)) 1000
So I was right? Awesome.
2**n * sin (pi / 2**n)) 1000
so try something that allocates more thunks.
hax
is ghci threaded or unthreaded. I tried "ghci -threaded" and it said "Warning: -debug, -threaded and -ticky are ignored by GHCi".
f n) 0
roadfish: ghci is threaded
ghci is "threaded"
(ghci is a very odd thing)
ok, and I'm guessing that I can't request an unthreaded ghci
roadfish: you should try compiling your own ghci with the unthreaded runtime
just for shits and giggles :D
ok, I'm trying it now
roadfish: try -fno-ghci-sandbox
I think that a good 20% of ghc exploration is shits and giggles
if this involved modifying GHC, the other 80% is waiting for it to compile
good luck compiling it now. HEAD doesn't build at the moment
haha
XD
someday i will be a bad enough dude to HEAD ghc
a build that's never broken means you're not doing things that are interesting enough
or it means you have developers that don't commit broken stuff
It's difficult to keep HEAD unbroken.
this is the culprit http://hackage.haskell.org/trac/ghc/changeset/97db0edc4e637dd61ec635d1f9b6b6dd25ad890c
ok, I got "fix: <<loop>>" when I did "ghc fix.hs;./fix"
http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/965006902_6djpLdS
but I noticed that "runghc fix.hs" just froze up.
parcs: SPJ's fault? :O
not segfault, but read this comment http://hackage.haskell.org/trac/ghc/changeset/97db0edc4e637dd61ec635d1f9b6b6dd25ad890c#file2
specifically "if a type signature is wrong ,fail immediately." GHC.TypeLits has a "wrong" type signature inside a constructor definition of GADT
of a GADT*
nice
oh damnit
oh wait, it's actually been fixed: https://github.com/ghc/packages-base/commit/4f27b5710232be868121cce5191c062999107327
Just ()
Nothing
sequence?
sequence
or not...
sequence [Just (), Just ()]
mconcat . sequence
foldl1 (>>) [Just (), Nothing]
foldl1 (>>) [Just (), Just ()]
mconcat . sequence $ sequence [Just (), Just ()]
oops
mconcat . sequence $ [Just (), Just ()]
: (
StateT PlayerState m a" to use MonadState instead?
m a
`nand`: seems to imply that the state's type in the second parameter is the same as state's type in the return value
oh
my bad
the method returns a state action that zooms on a particular planet in PlayerState and then executes the PlayerWorld state action
whats the diff between PlayerWorld and PlayerState
m' a
oh
but that's not the same
reltuk: If you 're using lens, you can use the "zoom" function for that
since it assumes different stacks at the top
or well, doesn't assume the same stack
otherwise you just need to get the outer state, run the inner thing , and put part back
and by â€˜at the topâ€™ I mean â€˜underneath the StateTâ€™
:t zoom
depending on what your code does, it probably can't be done - if you use runStateT or something, then the former parameter will have to be StateT PlayerWorld m a
heh.
Nereid: lens' types are nuts :-P
wait until 3.8
reltuk: transition i m = do s <- get; (x,w) <- lift (runState m (world s)); set (setworld s w); return x
otherwise you have to do something like that
with lenses you'd have: transition i m = zoom worldLens m
glguy: yeah, it's using zoom currently :-)
I didn't read your question correctly
:t zoom _2
lens is an attempt to produce a constructive disproof of the conjecture that type signatures make functions easier to understand
:t zoom (_2 :: SimpleLens (a,b) b)
blah.
lens is more an attempt to see if i can make a library that is useful enough to force people to learn new abstractions
edwardk: Or useless enough to force people to invent new abstractions!
edwardk: the problem is the library works too well
I don't quite understand Zoom; the type class mentions â€˜sâ€™ and â€˜tâ€™, but you still have to provide your own LensLike'?
you can use it without understanding it at all
and so they don't need to learn the types to use it?
yeah
execState (zoom _2 (put 3)) (0,0)
cmccann: I think edwardk is in it for the long term.
`nand`: the 's' and 't' are determined by your lens/traversal
edwardk: perhaps you should find ways to make it harder to use.
cmccann: When you start out, lens is easy. You barely need to learn any new abstractions.
well, I guess that's why you keep shachaf around.
But later just plain lenses aren't enough. You start wanting traversals here and there. Maybe a prism.
shachaf: yes, i'm slowly turning the thumbscrews
jwatson pasted â€œSPOJ 1â€ at http://hpaste.org/80519
cmccann: Puzzle: Why is Upseta and Unsettle so horrible?
Either t a }
t }
A lot of the type craziness comes from wanting to quietly overly things to pass indexes through, to be able to be reversed, etc
i added lenses to both parsers and trifecta the other day, it made a HUGE difference in legibility
overly->overload
glguy: yeah, with lens i admit i've been willing to bend over backwards to get little bits of generality
Well, trifecta was already a pile of abstractions.
edwardk: oh, the â€˜sâ€™ and â€˜tâ€™ are there so they can affect â€˜mâ€™ and â€˜nâ€™
`nand`: the point of zoom is: if you have a lens into a part of your state, then you can lift a State action on that part to an action on the whole.
usually because after i do that 3-4 times, the new thing is much simpler than what i brute forced to start with
so
one example is
Nereid: even better, if you have a traversal, it'll run your action multiple times, focused in on each target, an stitch together a monoidal summary of each thing it did
State t a
you can zoom traverse
really.
that's pretty cool.
shachaf: I dunno, but I'm assuming it's your fault, whatever the reason is.
shachaf: how.. unsettling
cmccann: Uhh, can I blame elliott?
State [s] m
cmccann: It's at *least* half his fault.
no surprised.
execState (zoom traverse (modify (+1)) [1,2,3]
shachaf: you're saying he was a coconspirator?
execState (zoom traverse (modify (+1))) [1,2,3]
evalState (zoom traverse (gets Sum)) [1,2,3]
runState (zoom traverse get) ["hello","world"]
cmccann: We were actually working on k2.hs together in a shared editor session.
shachaf: i'm planning on reconsidering plumbing the q's out of each function, but probably not the existence of index-preservation as a whole
evalState (uses Sum) [1,2,3]
er
evalState (uses id Sum) [1,2,3]
i'm also down with the idea of dumbing lens and mapped/lifted back to non-preserving
ah, () is a Monoid; I think that's the first time I've seen this instance really come in handy :)
edwardk: Well, index preservation on things that can't be indexed anyway isn't so bad.
(other than monadic folds or w/e)
edwardk: By the way, does index = measure for Isos?
jwatson pasted â€œSPOJ 1.0â€ at http://hpaste.org/80520
I wonder whether indexes become measures in oppositeworld or something.
That would be neat.
is there a better way? http://hpaste.org/80520
execState (modify (traverse +~ 1)) [1,2,3] -- of course, this is a much simpler way to do that
shachaf: i've been using the Indexed class as the Measured type we talked about in testing
of course.
er Indexed data type
(form https://www.spoj.com/problems/TEST/)
execState (traverse += 1) [1,2,3]
(traverse +~ 1) [1,2,3]
map (+1) [1,2,3]
yay, simple again ;)
[2,3,4]
[2..4]
[2..4]
getContents -- or something
Nereid wins.
Hahah.
map (+1) 1:2:3:[]
dang it, I was typing that, Nereid !
map (+1) (1:2:3:[])
@let ha = [2..4]
there is a deliberate connection between exectState (foo += ..)  and foo +~ ...
ha
which would give you an IO [String], which you could then mapM_ putStrLn I guess
@let h = [2..4]
h
Damn.
or bind (putStr . unlines), w/e
Ha.
@unlet
`nand`: thanks!
ha ;)
@let a = 'Ã¡'
do you guys see anything untidy about     newVal <- (foldl' (<=<) f (replicate 1000 f)) val
a
@unlet a
@undefine
a
oh
concat ["Ã¡"]
Ord (a,b)"?
crclark: No, that definitely conflicts
crclark: make a newtype for your fst component with a dummy Ord instance :)
Yeah, the solution when you want to get an instance with different behaviour is usually just to make a newtype wrapper
crclark: When an instance is being selected, the contexts on the instances are *ignored*, and only once the instance is chosen do they get enforced.
Ord (a, b)"?
crclark: This is because the compiler can never assume that an instance absolutely doesn't exist while compiling a given module, because there might be an instance in a module it hasn't reached yet.
Could not deduce (Zoom n m k0 PlayerWorld PlayerState) arising from a use of `zoom' ...  The type variable `k0' is ambiguous ... Possible fix: add a type signature that fixes these type variable(s)
Cale: aha, that answers my question entirely. Thanks.
(or which hasn't even been written yet)
reltuk: paste.
i'll try to distill it...it's surrounded by junk :-)
reltuk: If you're making a function that is polymorphic in m and n, you're going to need a Zoom constraint on your function
how does a Setup.hs look for dependencies? isn't it supposed to be reported by ghc-pkg in PATH? are there any incompatibility issues with Cabal-1.14 with ghc-7.6.1?
glguy: does the zoom constraint have to specify an actual transformer?
reltuk: the m and n pick k, you might have to manually thread that through somehow to the first argument of zoom
Monoid = Semigroup . Maybe ;)
merp...it's gonna leak everywhere if i add that constraint :-P
mephx: do you mean dependencies listed in the .cabal file, or dependencies for the actual Setup.hs module?
the Cabal library uses the dependencies listed in the .cabal file to instruct GHC to only show packages that match the requirements when building
ivanm: while running ./Setup configure --prefix=myprefix
it is possible, however, for a custom Setup.hs to require modules that aren't actual package dependencies
mephx: OK, for building the actual package; it grabs the dependencies from the .cabal file, and then tells GHC to hide every package _except_ the ones that match the requirements
on Cabal-1.14, says "base >=4 && <3 && >=2 && <5" I have
base-4.6.0.0
mephx: sounds like silly upper bounds dep on base
<3 ?
Nereid: nah, its probably confused by another upper bound
although the <5 is seems ok, there might be some flag or something
I'm trying cabal 1.16 now
base â™¥
mephx: oh yeah, cabal 1.16* is required for ghc 7.6.1
and Cabal-1.16.0 should already be installed...
Setup: At least the following dependencies are missing:
base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6
I have unix 2.7, and base 4.6 =|
which package is this?
Cabal-1.16
why are you trying to install Cabal-1.16?
it should already be there...
haskell-7.6.1
ghc-pkg list Cabal
if you mean ghc-7.6.1 ... it comes with Cabal-1.16
indeed
there he is :|
so why are you trying to install it?
ivanm: though that it only came with hp, unnavailable for 7.6.1
huh?
Cabal ships with GHC
cabal-install doesn't
two entirely different things
ah, then I'm on the road
reltuk pasted â€œzoom and MonadStateâ€ at http://hpaste.org/80521
cabal-install, same error
mephx: if you want to build and install cabal-install (and you don't already have one from a previous install), get the tarbal, unpack it and run the bootstrapping script
basically the question is, can i keep the surrounding functions general in MonadState and still use zoom...probably not
the boostrap script throws out the same errors
base and unix
which version of cabal-install?
1.16
why not the latest one?
1.16.0.2
ivanm: yeah that one works
branch?
why are you wanting a branch?
http://hackage.haskell.org/package/cabal-install-1.16.0.2
there's a tarball link down the bottom
gienah: even 1.16 should work IIUC
haha, my quote about blaming shachaf ended up in HWN.
wget http://hackage.haskell.org/packages/archive/cabal-install/1.16.0.2/cabal-install-1.16.0.2.tar.gz && tar xaf cabal-install-1.16.0.2.tar.gz && cd cabal-install-1.16.0.2 && ./bootstrap.sh
mephx: ^^
already running
thanks for the effor though =)
cmccann: HWwhat?
parsec, network, I'm good
he finished moving apparently.
edwardk: can you help reltuk ?
:c
cmccann: Seems to me that elliott is in the lead.
done, thanks
cmccann: Also, we're running dangerously low on lens quotes.
shachaf: yeah but half the quotes at least are from #haskell-lens regulars
the HWN quotes section is basically lensketeer comedy hour, this is not a new development
So mirrored first = loop, and mirrored loop = first
stylistically, should i just not be writing these functions against MonadState?
reltuk: which functions?
statusfailed: sorry, was an older hpaste: hpaste.org/80521
yay, zoom
is there some obvious way to map a monadic function over the values in a Data.Map?
such a useful function
for some reason foldable has a mapM_ but no mapM
Hello
New haskell user here
ohh, it looks like that's part of Traversable
m (Map k b) ?
CodeDmitry: hello!
statusfailed: i'm currently replacing my uses of it because i can't make it type check :-P
ah :P
I think that code can be written without state at all right?
because you know both types in advance
so it's not like you need to embed the PlayerState in some unknown larger product type
hi
the lenses that you use are always going to force the type that is held in the state, right?
Hello :-)
So painful to read haskell documentation
CodeDmitry: it gets much easier with practice :)
Or to find what u need when u need it
what's something that's foldable but not traversable?
reltuk: Well, you can write a zoomed state function without binding the 'outer' state type, right?
(as long as you pass in the lens)
crclark: Set
er croikle
quick question: does something like: function (x:xs) | test x = x : xs incrue a performance hit?
yeah, the alternative is to write MonadState a m actions that take a (SimpleLens a PlayerWorld) as an argument
SamanthaD: it'll take the cons cell apart and build a new one if thats what you mean
that can cost you sharing
function xxs@(x:_) | test x = xxs    avoids that
SamanthaD: Yes, it does.
but that doesn't seem as natural as writing a MonadState PlayerWorld m action and then zooming on it
I benchmarked it at one point.
You can do what edwardk said, though.
edwardk: yes, it is. So it's better to use head in the guard rather than the syntactic sugar.
SamanthaD: or use the as pattern like i did there
SamanthaD: No, don't use head. Use @
edwardk: ooh, thanks
shachaf: much thanks for the knowledge
Matching on foo@(x:xs) matches x:xs, and also gives the name "foo" to the whole thing.
shachaf: I'm afraid I don'kt know how to use @, what's it called?
OH
shachaf: @ is syntactic sugar for let?
No, it's a special matching sugar.
What does x:xs mean, its everywhere
let f a@(b:c) = (a,b,c) in f "hello"
SamanthaD: â˜
CodeDmitry: it means x cons xs
Whats cons
x is the first element in the list, xs is the rest of the list
1 : 2 : 3 : []
Head,tail?
let (x:xs) = [1,2,3] in show x ++ " " ++ show xs
: puts a new element on the front of a list when used as an expression
CodeDmitry: Oh, cons is when you take one item and stick it in the head of a list. So what you're doing when you have x:xs is that you're taking the head of a list and the remainder of the list.
when used as a pattern it matches the head and tail
CodeDmitry: yes, exactly
Concatenation? Isnt there a function for that?
I love how helpful and friendly #haskell is <3
CodeDmitry: Yes, there is. But sugar makes your code look sweet.
reltuk: i'm not sure why that function has to be stateful actually
What sugar
statusfailed: .= ... it's reduced from a larger program, of course
CodeDmitry: "sugar" is what you call it when you have more than one way to express something. For example, you can use guards instead of if-then-else.
So much superfluous terminology in this language
no, sugar isn't that.
and guards are more powerful than if-then-else
CodeDmitry: This sort of thing is covered in more detail in most introductions to Haskell. Are there any that you're reading?
What are guards
well,  function (x:xs) | test x = (x:xs) doesn't necessarily create a new cons cell;  it depends on how much you want to trust common subexpression elimination.
@where lyah -- often recommended in here
statusfailed: i got rid of focusPlanet and replaced it with composed lenses and operating on PlayerState...but now I have to rewrite all the stateful functions in that module to actually operate on GameState instead and select the player
I have tried reading many haskell documentations
http://www.haskell.org/haskellwiki/Tutorials
i think sticking with MonadState is the wrong idea
lists some good places tos tart
LYAH is pretty popular
reltuk: you can zoom if you don't want to select
CodeDmitry: it's a statement that must return true before the rest of the statement is evaluated. You'll get to them usually near the back of most tutorials.
things work well if I use StateT...
When i hear mathematical terminology in programming when simpler terms could be used, i get confused and angry
reltuk: having trouble zooming around when you have a MonadState constraint?
edwardk: yeah...I could get it to work without concretizing on a state monad type
distilled example: http://hpaste.org/80521
reltuk: yeah, thats the unfortunate downside of lenses is that zooming forces you to a concrete state monad =(
CodeDmitry: But... how else would you describe a mathematical concept?
one way around this is to use makeClassy and build big composite states rather than zoom much
There are many ways to describe mathematical concepts with natural analogies, or plain logic
Without resorting to 'deductions'
reltuk: you can solve this in a few ways
CodeDmitry: I prefer the mathematical names. Especially when you have a concept like monads. I mean... you don't call arrays "grid like things," do you?
one is to move the State to the outside
so its the outermost thing in the transformer stack, then you can use zoom on it without crazy signatures
just work with StateT s m     where m is a monad transformer stack
and then zoom won't incur any funny dependencies on m
Arrays are standard types that every programmer naturally understands, although lists are simpler
this isn't very satisfying, but it does give you zooming
reltuk: sorry ,I totally misunderstood the purpose of your question!
and its still less of a restriction than what we used to do have to do with data-lens
m a
But the ghci errors are incomprehensible
is that m and n are completely unrelated.
Like 'ridgid type'
CodeDmitry: well not naturally- arrays aren't _that_ easy when you first teach someone to program
Good luck googling it
CodeDmitry: Only beacuse most languages take them for granted... Haskell and functional programming are ACTUALLY significantly different than imperative languages so if you're approaching it expecting to only need concepts you're used to from other languages you're going to get very, very frustrated...
n could be IO with missile launches, etc. while m could be just 'State'
Zoom has all those crazy constraints to relate the two types
CodeDmitry: ghci error messages are pretty horrible for beginners, but you seem pretty averse to learning in general
sounds good. are there downsides to StateT being outermost?
Define averse
so thats one solution, another is to do something like what the Lensed monad does inside of the snap framework. they have a custom monad you can move around in which usually lives on the outside
CodeDmitry: What I'm saying is that we're not being obtuse just for the sake af it ;)
honestly I never found ghci messages bad -- the nice thing is generally you only hit ~5 of them
I never seen obtuse used in that context
>.>
reltuk: well, it is a pretty reasonable place to put it, there are some ways it interacts with cont but other monads generally don't care
its also probably the most sensible place relative to error for many uses
anybody has had luck with the haskell FFI and Rust (mozilla lang)
has anybody had.. (sorry my engRish is showing)
CodeDmitry: I think he's saying that you've barely got your toes wet in a language but you seem to be passing judgement on how the language does things beacues they don't match what you're expecting of it. The thing is, it's significantly different than anything eles you've probably ever seen but it's that way for a reason. Try to give it some time and pretend you don't know how to program at all. That's the best way to approach it.
I spent a few last days just to find a way to turn a string to num
>.>
'k, we're just gonna do that then.  thanks a bunch edwardk :-)
np
Never seen such a huge learning curve in any language i tried in last 9 years
>.>
CodeDmitry: Prolly gonna have to use some kind of string parsing library for that...
I ended up using show mystring::Int
CodeDmitry: You know what... Have you ever tried Scheme or any of the other Lisps?
read "123" :: Int
CodeDmitry: remember you can always use hoogle and Hayoo
Read*
read "123" :: Float
path, what am i doing wrong
I used hoogle, go hoogle atoi or toint ... or anything relevant
It wont suggest read a::Int
Oops
CodeDimitry: usually in hoogle you put type signatures
i'm trying to use the monad instance of maybe and lift it into the IO monad
the one other problem i was having with lenses was returning one from a monad
but i think from the documentation i just need to a loupe
is that correct?
Num
a
I dont know why there is no fromintegral function
Tointegral*
b
@ty toInteger
b
CodeDmitry: wait... you want to transform an integral to a string? That's easy. Use the show function!
CodeDmitry: there you go, ceiling, floor, round
No i just wanted to know how to turn num back to integral
Kinda silly not to have tointegral
not all things that are Num can be Integral
but all the "things" on RealFrac can be approximated, so can be converted to Integral
CodeDmitry: floats and doubles, to be exact, can't be integrals.
exactly, that why you have to approximate them
for example 'Complex numbers' are Num but not RealFrac
also not Integral
Integrals can be floats,doubles?
no, but can be approximated
CodeDmitry: if you need to turn a Float/Double to an integral you ought to use either ceiling, floor, or round.
floot 5.5
floor 5.5
ceiling 5.6
CodeDmitry: floats and doubles can NOT be integrals!
Floats,doubles are nums?
CodeDmitry: yes, they are... but not all nums are integrals!
Yes.
How curious...
isn't it?
CodeDmitry: Integrals refer to int and integer only.
CodeDmitry: In other words, only bounded or unbounded integers.
Is there a reason to use integral over int?
CodeDmitry: generality
@lyah
Example?
CodeDmitry: Yes, you use integral when you want your fuction to be polymorphic. That is, when you want your function to be able to accept both int and integer you can use integral.
what if you developing need an arbitrary large number?, you would have to change signatures just to use Integer
Int is not an integer?
no
10^100 :: Integer
10^100 :: Int
heh.
maxBound :: Int
maxBound :: Integer
Int is the 32 bit int?
IO (Maybe a)
CodeDmitry: depending on your platform, yes
CodeDmitry: on a 32-bit machine, yes.
as basdirks says
CodeDmitry: Integer is *UNBOUNDED* it has no upper or lower bound at ALL. It will continue going up till it takes every last byte in your computer's memory and swap!
Integral is an adt?
No, a typeclass
maybe (return Nothing) f a
CodeDmitry: Could I suggest you read Real World Haskell? It really gets into these kinds of details.
er
it's a typeclass, have you learned about those yet?
which is a fancy way to say that every instance of Integral (example Integer, Int) has defined operations for them
maybe (return Nothing) (liftM Just . f) a
CodeDmitry: both http://learnyouahaskell.com/chapters and http://book.realworldhaskell.org/read/ are pretty good
Nereid: hmm i thought there was a more succint way to do it
maybe it's not what you want.
and if you have questions about the material you can always ask here
Ill look into it... but i learn better from more assertive claims answered with yes/no , with exceptions
:t Data.Foldable.forM_
:t Data.Foldable.forM
CodeDmitry, you probably want both ways
er..
I am
:t Data.Traversable.forM
CodeDmitry: I'm afraid Haskell has a lot of new concepts that can't just be given to you in yes/no answers...
yeah.
that's the one.
where t = Maybe
CodeDmitry: well as a teacher, I can tell you only *really* learn by getting your hands dirty
But reading books without knowing the obviousis hard
NemesisD: ^
CodeDmitry: they show you the right questions
Haskell books assert a lot
which we can yes/no to
CodeDmitry: just ask what you don't know =]
Nereid: weeeird. my brain has a hard time grokking how one "traverses" these datatypes
I am, and you guys are very helpful
:-)
cool
:t traverse
CodeDmitry: I want to caution you against what you seem to be doing though... I get the feeling based on the questions you're asking that you're trying to figure out how to translate the way you program now into a new syntax.
Data.Traversable.sequence works too, it looks like
I fear recursions due to some error with infinite in it
NemesisD: traverse k x will take all the things in x, run the action k on each of them, and collect the results.
mapM = traverse
CodeDmitry: The problem is... Haskell isn't a new syntax. It's a new methodology. You need to re-think the way you structure the program.
Nereid: the word traverse hints at a collection of things, which is weird since its a Maybe, not a collection
a Maybe is a collection that may contain 0 or 1 things.
CodeDmitry: we have come to fear loops due to some errors with state in it
heh fair enough
CodeDmitry: don't worry, usually we don't do recursion when we can use combinators
although both are pretty easy
so if it's Nothing, then nothing will happen. if it's a Just, then it'll run the action on that one thing.
and put the result back in the Just.
It is, however i am not trying to translate, just polling for ideas on how a normal person would do it
yitz: Not to mention that loops are an inheritly imperative concept!
slack1256: did you get my last message?
my connection is being flaky
inheritance is inheritly inherative.
Im learning haskell for the paradigm, there  is no best pure paradigm
Nisstyre: sorry no. could you repeat. (also my connection is not that good)
slack1256: Rust is alpha quality atm
don't expect it to work perfectly
But a lot of concepts are pretty useful
CodeDmitry: I would beg to differ but I'm also a lambda zelot ;)
Nisstyre: if it wasn't alpha I wouldn't be so excited!
That, and haskell expresses math pretty well comparedto other languages
CodeDmitry: have you read the Structure and Implementation of Computer Programs?
CodeDmitry: insofar as math = abstract algebra
which, well, it's a massive amount of math :P
SamanthaD: well, not completely. sometimes it is natural to express an algorithm as a series of steps. but imperative programming confuses that with direct commands to a machine.
Is it a book?
it is a book.
CodeDmitry: it is, but you can find it on the internet.
SICP is a textbook that was used for a number of years at MIT (and is still used at other schools I think)
@where sicp
first one.
I took data structures course in my university
yitz: it's more declarative to say x is a recursion of x than "loop it" is what I'm saying.
I had so much trouble implementing a trie in c
also there is videos of sicp on openCourseWare at MIT
SamanthaD: you can compare it to recipes for cooking. often they are expressed as steps. but a more sophisticated cook will just use that to understand the recipe at a higher level, and then not necessary follow the steps exactly.
you can hear the awesome intro tune if you watch the lectures too
CodeDmitry: Anyway... SICP is a great stepping stone to functional programming I find. As is Scheme (the language SICP uses).
Generic steps are fine
CodeDmitry: Besides... SICP is very valuable to read no matter what.
http://youtu.be/ymRyefYC05k?list=FLcBI0SEgnOBJYWN24P3oPbA
Not all series of instructions follow on 1 way to solve a problem
SamanthaD: and that's pretty much what the compiler does when you express an algorithm monadically.
yitz: I see what you mean. You're saying the experienced cook is doing something like implementing transients (from Clojure). I kinda wish Haskell had a syntax for blocks of imperative code that are, as a whole, referentially transparent.
edwardk: watched the video of your talk about Lenses today. Really informative!
SamanthaD: "declarative" is a vague word. Something is "declarative" when it's close to what you want to say, maybe.
yitz: point taken... as they say, syntactic sugar rots your teeth ;)
If what you want to say is a loop, then a loop is declarative.
SamanthaD: we use monads for that. not familiar with clojure transients, so i don't know how that compares.
What is sugar...
SamanthaD: but it taste soooo good.
also Haskell isn't really declaritive because it also includes interrogative statements
/pedantry
Define sugar
AfC: =)
you kinda need both "this is" and "what is this?" to do programming
yitz: transients are like closures only that you're guarateeing that the closure is referentially transparent when it's called. I think it's a neat language feature.
Nisstyre: i haven't figured out yet what you are referring to. could you pls explain?
What is sugar
yitz: declaritive and imperative, you know what those mean right?
Nisstyre: Technically no language is truly declarative because a purely declarative programming language isn't very useful...
SamanthaD: well every haskell function is like that.
SamanthaD: exactly, it's a bit of a misnomer
Isnt xml declarative?
CodeDmitry: it's not a programming language
Nisstyre: yeah. i didn't get the interrogative part
CodeDmitry: Sugar is just a awy of saying "more than one way of doing the same thing syntactically"
yitz: it means asking questions
Tmtowtdi in perl?
okay, I'm done philosophizing about programming
Or something like that
I only program to feed my philosophical urges
Nisstyre: ok let me try again. what do you mean by saying that haskell "also includes interrogative statements"</interrogative>
Nisstyre: Now now! I'm pretty sure what we call a "markup language" is more or less what a math geek would call a purely declarative language!
SamanthaD: well it's definitely a language that is declaritive
Does that mean im right_
.
?
Im never right :-)
Nisstyre: After all... about the only thing a purely declarative program can do is interpret itself and that's pretty much what, say, an HTML document does!
yep
CodeDmitry: Yes, XML is declarative.
Well doesnt all code get interpreted at some point?
S-Expressions would also fall under the purely declaritive category if I'm not mistaken
Until then its pretty much declarative
CodeDmitry: well yeah, it's decided what each thing is by the parser
Nisstyre: how do you figure? I always figured s-expressions were just a very convenient way of imprementing circular reflexion.
CodeDmitry: but a declarative programming language cheats just enough to make it useful ;)
I mean even machine code is interpreted by the machine
SamanthaD: Well I don't know if I have the same definition of S-Expressions, but I just mean sexprs as you would use them to represent data
like sxml
CodeDmitry: Oh... yeah... but it's being interpreted by something else (aka, the processor) and not by itself, which is what I meant.
Still xml is pretty odd, you need very high level of maturity to understand a use for it
I want to make a fairly simple web application. I don't want much in the way of a framework; I don't need session handling or form generation or templates or anything like that. What's the difference between snap, yesod, and warp? Is warp a part of yesod?
Nisstyre: OH! I was thinking Lisp!
SamanthaD: I don't mean all of lisp really
jdavis: sure you don't want a static site generator?
Why do haskell coders refer to lisp so often
jdavis: no warp is only written by the same author as yesod, but they are two separate things
Yes, I am just trying to write something to turn PG functions into a web service.
CodeDmitry: because many of us learned lisp before Haskell?
CodeDmitry: Because Lisp is freaking AWESOME, that's why ;)
jdavis: warp is a web server. like a simplified nginix
actually, specifically Scheme is what I know
I don't have much use for CL
jdavis: http://softwaresimply.blogspot.com/2012/04/hopefully-fair-and-useful-comparison-of.html
I never learned a lisp.
Nereid: BLASPHIEMER!
in apple the say "there is an app for that" in haskell "there is a blogpost for that"
unhygienic macros make me feel dirty
I also don't know lisp
but I am a full blown pagan so it doesn't matter
I know defun is a keyword, does that qualify as knowing lisp?
jdavis: if you just need a static web site, hakyll is really good
Basically, all I want to do is connect to postgres, look at the catalogs and turn each function into a web service of some kind, served by a simple webserver. Does warp sound like a good fit? It looks simple and reliable and fast.
jdavis: if you want small, you can use wai directly, or scotty sounds pretty simple
yitz: well, I need to connect to PG, so static won't work.
warp is just the webserver part
jdavis: what is a PG?
slack1256: you can do things like this: (define-syntax-rule (let ((a exp)) body) ((lambda (a) body) exp))
slack1256: sorry, PostgreSQL
I, for one, would consider Scheme to be my one and true love if it wasn't for the fact that I'm scared to leave my beautiful Hindley-Milner type system O.O
(not tested, may be syntax errors in that)
jdavis: oh i thought Paul Graham lol
SamanthaD: Typed Racket?
jdavis: hmm well unless you want to hack directly in a low-level pg lib, you probably do want a framework then
Nisstyre: what does that buy me?
I made a promise to my imaginary girlfriend not to touch lambdas, they are evil
Nisstyre: My understanding is that typed racket isn't really all that statically typed...
slack1256: let
SamanthaD: oh, well I've never used it myself
Nisstyre: oh boy
slack1256: a primitive form of let though
Nisstyre: The problem with Lisp and static typing is that you can't have static typing when the damn program is writing its own executable code during runtime.
yitz: I'm fine with the low-level binding. I have already worked with it a little bit. I don't want an ORM or anything resembling one. I just want to call functions and process the results.
but you can do stuff like (let ((a 12)) (* a a)) with it
Niss, incomprehensible
SamanthaD: true enough
Nisstyre: So... the one feature that makes Lisp really special is fundamentally incompatible with a static typing.
CodeDmitry: equivalent to "let a = 12 in a * a"
jdavis: just use Snap. Easy to use, no fuss.
SamanthaD: but i thought that at least SBCL used internally type inference.
AfC: Oh, OK.
I try my best to keep my programs away from self obfuscation
AfC: Thanks.
It has been hard but i manage
CodeDmitry: I admit that it is difficult to read lisp at first, but it gets easier
especially if you use Racket, because it lets you use [ ] and { } instead of ( )
then you can do (let ([a 12]) (* a a)) instead
slack1256: I'm not sure... I know Common Lisp and Scheme are strongly typed in that if they hit a type conflict they'll cause a runtime exception... and they might have very limited abilities to do type checking at compile time but...
jdavis: yesod has persistent. hapstack has acid-state. snap has a database interface too, not sure that it has name though.
*happstack
OK.
yitz: remember that component are pretty much interchangeable on the 3
jdavis: you can use snap-core and snap-server directly if you don't need anything higher level. Snaplets are a powerful abstraction, but if you're just doing some simple HTTP handling then you can work directly in the Snap monad and be done with it.
slack1256: yep
slack1256: I don't think you could have a weakly typed Lisp. If you did, circular reflection would let you make such a huge mess so quickly it would be unbelievable >.<
Scheme is definitely strongly typed, but it will try to run a procedure with whatever you give it
Mess is fun, proven by c
Racket does a bit better with contracts, but they're still runtime
jdavis: snap is fine. yesod is also extremely easy to get started in. it also has a lot of great on-line documentation plus an oreilley "animal" book.
AfC: That sounds like all I need. Route /funcname?arg1=10&arg2=foo to some code that calls the postgres function "foo(10, 'foo')"
yitz: how up to date is the OReilly book?
jdavis: and happstack is also fine btw.
yitz: which animal? a pig? </runs>
I still believe haskell is perls evil brother
@slap slack1256
Nisstyre: I always write Haskell style contracts in my Scheme code anyway.
sorry sorry, it was too at hand.
Nisstyre: came out quite recently actually. definitely usable with current stable yesod versions.
CodeDmitry: Haskell is more like an extremely nerdy cultist obsessed with purity.
yitz: thank you.
Arent mathematicians geeks, not nerds?
CodeDmitry: other way around
oh, i needed reifiedlens
it's all the same thing geek nerds, nobody cares
also some mathematicians really were cultists >.>
I guess that makes me a geek >.>
All mathematicians are cultists
Its a fact
slack1256: Yes... and "hacker" is just a knighted nerd!
then what was Pythagoras?
an ub3r-cultist?
Pythagoras was a logician
Wasnt he?
well only the people who call themselves care about nerd and geek and stuff
more like a natural philosopher imo
aka physicist
Math is really painful if taught by cultists
Philosophers make better teachers
CodeDmitry: I dunno... philosophers really know how to bloviate...
Bloviate?
CodeDmitry: babble
Ah
except for a select few, who started out as mathematicians :P
There are many mathematicians without any critical thinking skills
Nisstyre: Yes, but they're a special breed ;)
CodeDmitry: that is true
SamanthaD: you have to be to smoke a pipe every day and live to be 97 (Russell)
Nisstyre: My trachea is a catalytic converter!
Haskell seems to be more of a challenge than a language though
haskell is a real language.
To think differently
surprising isn't it!
It really is
CodeDmitry: premised on the fact that you learned a pl previously
CodeDmitry: Haskell is definitely a useful language... it just takes a lot of practice to make the pradigm shift.
Pl?
programming language
I believe newcomers will also have issues
[citation needed]
but I've seen haskell teached to people with no computer background and they catch pretty quickly
CodeDmitry: For example, Haskell has huge potential when your program absolutely positively must do what you intend it to do.
 Its natural to think of a computer as a state machine
CodeDmitry: I know of professors who teach Haskell to undergrads with little or no PL experience and it goes over fine generally
CodeDmitry: hahahaha
And recursions are far more confusing than loops
CodeDmitry: my hair is a bird. your opinion is invalid.
CodeDmitry: [citation needed]
Professors will find haskell an ideal tool for their purposes.
CodeDmitry: first define "natural" operationally
CodeDmitry: natural only applies to domains, for other expectation whta is natural there doesn't have to be here
what is natural is subjective in casual speech
CodeDmitry: I come to Haskell as someone who needs to write scientific programs. I like the fact that I can write proofs about my programs and PROVE that they're doing what I say they are.
CodeDmitry: or if I can't absolutely prove it I can get very close.
SamanthaD: what is your major?
Computer science
@quote kmc unless
University of ryerson
CodeDmitry: you live in Toronto?
Vaughan
2 hours to get there
I see
Worst case
I know someone who lives in Toronto and goes to McMaster
slack1256: strangely, psychology...
slack1256: but you can model people, too ;)
I like ryerson, if i had to choose between it and anthing else, id choose ryerson
I can't imagine the busing it must take every other dayt
*day
SamanthaD: that's cool!, also you can automate a lot of statistics with programming
SamanthaD: I'm majoring in linguistics
f-ing 8:30 lectures :(
Nisstyre: why are you awake then?
slack1256: insomnia I guess
could also be because I got up at noon since I had no reason to get up otherwise
slack1256: Yes, you can automate a lot of statistics. Though... we already have a very good stats suite so...
go to sleep man, you won't understand anything otherwise
Claim: the amount of haskell that makes sense is directly proportional to how much math terminology you can comprehend
slack1256: okay okay, I'll go to sleep soon :P
it's on psychoanalysis though (personality course)
And yes, i got no idea what directly proportional means
not going to understand it regardless heh
CodeDmitry: multiplication
CodeDmitry: wrong, foundation of mathematics (metamathematics / lambda calculus) is very different from math
I actually just got out of my undergrad. I want to study biopsychology. What I really want to use Haskell for is modeling learning on a cellular level.
how much more powerful is haskell than java?
It isnt
SamanthaD: have you joined the biohaskell list?
ed__: 3.14
CodeDmitry: From my experience with the language that's not true...
SamanthaD: I'm hoping to eventually do a Masters in computational linguistics, hopefully using Haskell for that
CodeDmitry: Directly proportional means that one property is a function of another.
Java library is the largest standard library in any programming language
slack1256: I had no idea there was such a thing!
ed__: You're kidding, right? It's night and day!
is there a ling-haskell mailing list?
slack1256: seems very active
Good luck making portable guis in haskell
Let alone even installing one library
The cabal errors are incomprehensile
what about for web dev?
CodeDmitry: Sure... but it's also full of bugs. Not to mention that the JVM is full of bugs... the language is poorly designed and obtuse... it's based on what I would say is a poor implementation of an obsolete paradigm...
CodeDmitry: if you use GLUT you are fine, also wxhaskell is portable
ed__: haskell has 3 good frameworks with excellent performance for webdev
I tried setting up wxhaskell, it failed
ed__: seriously jump in. the worst thing that could happen is that you learn something :-)
CodeDmitry: Excuse me! There's plenty of portable gui support in Haskell!
shachaf: sorry.
CodeDmitry: at this point you're just trolling
Setting up the libraries is hell, and you have to do it on each targe platform
Its only a little easier than c++ to port
Which is total hell
CodeDmitry: Yeah, wxhaskell is about as close to portable as you can get!
CodeDmitry: you can use static linking and then you are pretty much set
I cant set up wx in cabal, it fails
ed__: Well... there's Yesod for server side web apps!
I cant make a user run cabal, and i cant precompile it on each platform
I cant promise no further issues neither
It is an issue
And i pray it statically links, i dont want dll hell
ed__: However, I would suggest learning Haskell just becaues it'll teach you concepts and disciplines that are actually applicable in other languages (and will improve the quality of your code). Just don't try to implement tail-call recursion in Java unless you like blowing your stack.
Yeah thats my main reason for learning it
I never backed up from a new way of thinking
you start that way, but then you end up wanting to write everything in haskell.
@SamanthaD thanks
Is there a better way to obtaining dependencies to your project to put in .cabal file than sticking some in, seeing if it builds and adding some when it complains?
CodeDmitry: Sure... but don't pretend that Java isn't problematic either when it comes to portability.
ed__: Yeah... I've never used Yesod though, but I heard it's in a stable release now? I dunno, not really my field.
ed__: I know it's BLAZINGLY fast. I'd say the biggest problem with writting a server-side Haskell ap would maybe having trouble finding a server that you can run it on.
Java is problem free in portability...
Is prolog FP langauge ? It seems there is no lambda in Prolog ?
no, it's not.
Eh?
Fuuzetsu: how is that? you imported the modules but don't know to to which package belongs?
to sw2wolf
sw2wolf: but it's declarative although not functional
mercury has a interesting approach on joining logic and functional
Prolog seems a interesting langauge
I gave up on hating paradigms a long time ago
slack1256: thx
CodeDmitry: In an idea world the JVM would ensure perfect portability. We don't live in a perfect world.
Jvm insures perfect portability, we live in a perfect world
CodeDmitry: are you fucking kidding me
JVM makes us lose thinking :P
Its much more interesting to hear the reasons for such javaphobia
CodeDmitry: no, it's not
CodeDmitry: everything has it's place and time
CodeDmitry: Consider that there's at least three major JVM implementations and each of those implementanions have different versions. Now, each of those JVMs (and their different versions) will compile your bytecode slightly differently... Yeah, explain to me how that isn't a recipe for poor cross-platform compatibility.
Like I said; he's now trolling
3 different implementors? Doesnt oracle have a monopoly?
OK GUYS I WILL GIVE YOU ONCE PIECE OF CANDY EACH OF YOU IF YOU STOP SPEAKING OF JAVA
"no"
is an argument actually going on with someone who said "Jvm insures perfect portability, we live in a perfect world"
and can it stop
CodeDmitry: What I said is a verifiable fact!
CodeDmitry, SamanthaD: stop.
elliott: he seemed semi-sincere a while earlier
well, still doesn't look to be haskell-related to me :p
sorry, I'll stop
That is interesting because all code i built on windows ran on mac and ubuntu without any noticible issues
it was about Haskell until he put on troll-mode
remember this is our bible http://www.haskell.org/haskellwiki/IRC_channel#Principles
Alright you do have a point, this is like pouring gas on a fire.
Ill avoid bringing it up n this channel
slack1256: I do know where they belong; it's just tedious going over every single pretty name (such as Network.URI) and finding the exact package name that it belongs to (network-version) for every single import
doesn't cabal init do that for you?
if you do it in a directory with existing code
that what I thought
I tried setting up wx and gtk with cabal both failed
CodeDmitry: paste the error on hpaste
Its very painful
ed__: Did you get your question answered, by the way?
I dont understand why haskell has no simple gui support, not even Tk
Not without cabal
CodeDmitry: well first is a thing of different paradigms
Nereid: Ah yes, it's done it! I couldn't remember what the command was, thanks!
Guis fits pretty well the OO model (as shown by smalltalk)
Gtk handles guis very well
It is oo c though
CodeDmitry: C is not obeject oriented, no...
but on haskell you can't do imperative without the IO monad. as a result too much code on the IO monad
C is capable of oo
you can pretend C is object oriented.
Ao is assembly
So*
CodeDmitry: Glib is a OO abstraction layer on top of C, they use it to make GTK work
but let's not go off topic again.
CodeDmitry: Also, Haksell can call foreign code and foreign code can generally call Haskell. If you really want to build your GUI in an object oriented way I might suggest you hybridize your languages?
Oo is essentially structuring sets into trees
In any case, i dont care about oo atm
I care about writing guis in haskell
the tutorial on WXhaskell are pretty straightforward
CodeDmitry: Perhaps you should look into the chapter in Real World Haskell on that subject?
Perhaps i should
K got it, 712 ish pages right?
read it online.
@where rwh
I got the pdf
which is less up to date
I think?
also the comment on the paragraphs are cool
Nereid: I don't think so... but I find the HTML version much, much more legible.
perhaps.
easier to copy and paste code too if you're into that
Looks like a pretty good book
:-)
CodeDmitry: Indeed! It's the best reference book for Haskell that I know of!
Heh thanks for the advice, ill try to make sense of it
CodeDmitry: The way I like to use RWH while learning is to keep it as a reference for when I want to get more details about a particular topic. I tried using it as a primary tutorial but... I dunno, it wasn't my cup of tea.
CodeDmitry: A lot of people like Learn You a Haskell as a crash course.
CodeDmitry: But... there is no substitute for Real World Haskell.
I don't remember how I learned haskell.
Nereid: I'm doing it by reading about five books at once ;)
Nereid: reading?
yes, I must have learned it by reading.
I remember looking at lyah and rwh but I don't think I ever finished going through them.
Nereid: "and suddenly everything was clear, my journey ended and i knew haskell... and he knew me" - Nereid 6 buddah of lambda
slack1256: Does that mean Nereid built an AI preprocessor for his code?! That would be pretty awesome!
there should be a haskell platform metapackage on hackage.
or something.
Nereid: There isn't?
not that I've seen.
Nereid: either way if you don't have the plataform you can't have cabal
Nereid: If you're on linux why don't you just install the haskell platform using your package manager?
because I don't want to.
fair enough
slack1256: not true.
hello?
anybody on?
nope
howdy69: Sure!
howdy69: welcome to the internet
hello howdy69
we're hiding
Nereid: I'm not sure what good a metapackage would be. I mean, if it depends on all of the platform, I won't install it
Where are you from? This is a neat service
hi
howdy69: Welcome to #haskell. We talk about Haskell here.
c_wraith never metapackage he didn't dislike.
Nereid: and if a package depends on the metapackage, it's very likely to have extraneous dependencies in its .cabal file
shachaf: true
you're not supposed to depend on a metapackage.
people would
You know it'd happen.
No, it wouldn't help.
true.
alright
Well, OK, maybe people would.
distribute a package that deliberately fails to compile
but installs all the platform packages first
though if hackage actually distinguished between real packages and metapackages, it could reject uploads of things that depend on metapackages
heh
do people depend on yesod-platform?
ooh, new firefox
new firefox supports retina MBP finally
maybe it has some other features, but after like 4 months of having this computer, that's the one I notice
c_wraith: Haskellscript! No? Darn...
why
erp
why's everything about monads always about >>= if <=< makes for prettier (and, imho, clearer) composition?
Tordek: my guess is historical reasons
but I very rarely use >=>
how come?
Tordek: do-notation is the reason IIUC.
I was writing a monad tutorial (not, like, to publish or anything, just because explaining something makes it clearer to me), and <=< made everything familiar to .
the very few times I do explicit monadic composition it typically uses >=
m b) functions isn't that common.
1 >= 2  -- monadic composition
â€œSamantha Davisâ€ pasted â€œPrime Generatorâ€ at http://hpaste.org/80523
I see. Thanks, guys :)
Tordek: Also: Try writing (>=>) using (>>=).
That's a nice definition.
Now write (>>=) using (>=>)
My program's pretty simple... but when I try to run it it seems to just suck up ungodly amounts of memory and generally be extremely slow
BTW, I wrote this in response to an article about "Nulls are bad; let's use Maybe!": http://www.reddit.com/r/programming/comments/15ymgp/why_weve_banned_null_in_our_codebase/c7su4t3 I wouldn't mind some feedback if someone cares to oppose any of my points?
By the way, my test condition was calling take 5 (primes) in GHCi
